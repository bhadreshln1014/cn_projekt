% ============================================================================
% LAN-Based Multi-User Communication Application - Technical Report
% Computer Networks Project
% Authors: Bhadresh L and Santhana Srinivasan R
% Institution: IIITDM
% Date: November 2025
% ============================================================================

\documentclass[12pt,a4paper]{report}

% ============================================================================
% PACKAGES
% ============================================================================
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{colortbl}  % Required for \cellcolor
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{array}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{tocloft}
\usepackage{titlesec}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{courier}

% ============================================================================
% PAGE SETUP
% ============================================================================
\geometry{
    left=1.5in,
    right=1in,
    top=1in,
    bottom=1in,
    headheight=15pt
}

% ============================================================================
% HYPERLINK SETUP
% ============================================================================
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    citecolor=green,
    pdftitle={LAN-Based Multi-User Communication Application},
    pdfauthor={Bhadresh L, Santhana Srinivasan R},
    pdfsubject={Computer Networks Project},
    pdfkeywords={LAN, Socket Programming, Video Conferencing, Python}
}

% ============================================================================
% CODE LISTING SETUP
% ============================================================================
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{pythonstyle}{
    language=Python,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=single,
    rulecolor=\color{black}
}

\lstset{style=pythonstyle}

% ============================================================================
% HEADER AND FOOTER
% ============================================================================
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\leftmark}
\fancyhead[R]{\thepage}
\fancyfoot[C]{IIITDM - Computer Networks Project}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% ============================================================================
% TITLE FORMATTING
% ============================================================================
\titleformat{\chapter}[display]
{\normalfont\huge\bfseries}{\chaptertitlename\ \thechapter}{20pt}{\Huge}
\titlespacing*{\chapter}{0pt}{0pt}{40pt}

% ============================================================================
% DOCUMENT BEGINS
% ============================================================================
\begin{document}

% ============================================================================
% TITLE PAGE
% ============================================================================
\begin{titlepage}
    \centering
    \vspace*{1cm}
    
    {\Huge\bfseries Indian Institute of Information Technology,\\[0.3cm] Design and Manufacturing\par}
    \vspace{0.5cm}
    {\Large Kancheepuram, Tamil Nadu\par}
    
    \vspace{2cm}
    
    {\huge\bfseries Computer Networks Project\par}
    
    \vspace{1cm}
    
    {\Huge\bfseries LAN-Based Multi-User\\[0.3cm] Communication Application\par}
    
    \vspace{1.5cm}
    
    {\Large\itshape A Comprehensive Socket Programming Implementation\par}
    
    \vfill
    
    {\Large\bfseries Submitted By:\par}
    \vspace{0.3cm}
    {\Large Bhadresh L\par}
    {\Large Santhana Srinivasan R\par}
    
    \vspace{1cm}
    
    {\Large\bfseries Course:\par}
    {\Large Computer Networks (Semester 5)\par}
    
    \vfill
    
    {\large November 2025\par}
\end{titlepage}

% ============================================================================
% DECLARATION
% ============================================================================
\chapter*{Declaration}
\addcontentsline{toc}{chapter}{Declaration}

We hereby declare that this project report titled \textbf{"LAN-Based Multi-User Communication Application"} is our original work and has been carried out by us under the guidance of our course instructor. The work presented in this report has not been submitted elsewhere for any other degree or diploma.

All the information presented in this report has been obtained and presented in accordance with academic rules and ethical conduct. The source code, documentation, and results presented are authentic and developed by us.

\vspace{2cm}

\noindent
\begin{tabular}{ll}
\textbf{Bhadresh L} & \textbf{Santhana Srinivasan R} \\[2cm]
\rule{5cm}{0.4pt} & \rule{5cm}{0.4pt} \\
Signature & Signature \\[0.5cm]
Date: November 2025 & Date: November 2025
\end{tabular}

% ============================================================================
% ACKNOWLEDGEMENTS
% ============================================================================
\chapter*{Acknowledgements}
\addcontentsline{toc}{chapter}{Acknowledgements}

We would like to express our sincere gratitude to all those who have supported us throughout the development of this project.

First and foremost, we thank our course instructor for providing us with the opportunity to work on this challenging and enriching project. Their guidance, valuable insights, and encouragement have been instrumental in the successful completion of this work.

We are grateful to the Indian Institute of Information Technology, Design and Manufacturing (IIITDM) for providing us with the necessary infrastructure and resources, including network facilities and computing resources, which were essential for developing and testing our application.

We would like to acknowledge the open-source community for the excellent libraries and tools that made this project possible, including Python, OpenCV, PyQt6, PyAudio, and many others. The documentation and community support for these tools were invaluable.

We also thank our classmates and peers who participated in testing our application and provided constructive feedback that helped us improve the system's functionality and user experience.

Finally, we thank our families for their constant support, patience, and encouragement throughout this project.

\vspace{1cm}

\begin{flushright}
\textbf{Bhadresh L}\\
\textbf{Santhana Srinivasan R}
\end{flushright}

% ============================================================================
% ABSTRACT
% ============================================================================
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

This report presents the design, implementation, and evaluation of a comprehensive LAN-based multi-user communication application developed using socket programming in Python. The system addresses the critical need for reliable, secure communication in environments where internet connectivity is unavailable, unreliable, or restricted, such as educational institutions, secure facilities, and remote locations.

The application implements a robust client-server architecture that provides five core communication features: (1) multi-user video conferencing with real-time video capture, compression, and broadcasting at 30 FPS; (2) multi-user audio conferencing with server-side mixing and jitter buffering for high-quality voice communication; (3) screen/slide sharing capabilities allowing one presenter at a time to broadcast their screen at 10 FPS; (4) group and private text chat with full message history and notifications; and (5) file sharing with chunked transfer supporting files up to 100 MB.

The system architecture employs strategic protocol selection, using UDP for time-sensitive video and audio streams to minimize latency, while utilizing TCP for control messages, chat, file transfers, and screen sharing control to ensure reliability. The implementation spans six network ports (5000-5005), each dedicated to a specific function, with careful attention to thread safety, concurrent operations, and resource management.

Performance analysis demonstrates that the application successfully supports up to 10 simultaneous users with acceptable latency (100-150ms for audio, 50-100ms for video) on gigabit LAN infrastructure. The video module achieves 10:1 compression using JPEG encoding, the audio module implements real-time mixing with approximately 23ms latency per chunk, and the screen sharing module balances quality and bandwidth through adaptive resolution (960×540) and lower frame rates.

The user interface, built with PyQt6, provides an intuitive Google Meet-inspired experience with modern material design, dynamic video grid layouts, collapsible side panels for chat and files, and real-time notifications. The application has been extensively tested in various network conditions and successfully demonstrates all required functionalities.

This project showcases practical application of computer networking concepts including socket programming (TCP/UDP), client-server architecture, network protocol design, multimedia streaming, concurrent programming, and cross-platform development. The complete source code, comprehensive documentation, and deployment scripts are provided for reproducibility and future enhancements.

\textbf{Keywords:} Socket Programming, LAN Communication, Video Conferencing, Real-time Streaming, Client-Server Architecture, PyQt6, Computer Networks

% ============================================================================
% TABLE OF CONTENTS
% ============================================================================
\tableofcontents
\listoffigures
\listoftables
\lstlistoflistings

% ============================================================================
% CHAPTER 1: INTRODUCTION
% ============================================================================
\chapter{Introduction}

\section{Background and Motivation}

In today's interconnected world, real-time communication and collaboration tools have become essential for productivity and connectivity. While cloud-based solutions like Zoom, Microsoft Teams, and Google Meet dominate the market, they fundamentally rely on internet connectivity and centralized servers. This dependency creates significant challenges in several critical scenarios:

\begin{itemize}[itemsep=5pt]
    \item \textbf{Educational Institutions:} Remote or rural educational facilities often lack reliable high-speed internet access, making cloud-based conferencing impractical or impossible.
    
    \item \textbf{Secure Environments:} Government facilities, defense organizations, and research laboratories frequently operate in air-gapped networks where internet access is deliberately restricted for security reasons.
    
    \item \textbf{Emergency Situations:} Natural disasters or infrastructure failures can disrupt internet services while local network infrastructure remains operational.
    
    \item \textbf{Privacy Concerns:} Organizations handling sensitive information may prefer to avoid routing communications through external servers to maintain complete data sovereignty.
    
    \item \textbf{Cost Considerations:} Internet bandwidth costs can be prohibitive in some regions, making local network solutions more economical.
\end{itemize}

These challenges highlight the need for a robust, standalone communication solution that operates entirely within a Local Area Network (LAN) without requiring internet connectivity. Such a system must provide comprehensive collaboration features comparable to cloud-based alternatives while maintaining the simplicity, security, and reliability of local network operations.

\section{Problem Statement}

The primary objective of this project is to develop a comprehensive, standalone, server-based multi-user communication application that operates exclusively over a Local Area Network (LAN). The system must provide a complete suite of collaboration tools enabling teams to communicate and share information effectively in environments where internet access is unavailable, unreliable, or restricted.

Specifically, the application must:

\begin{enumerate}[itemsep=5pt]
    \item Implement all network communications using socket programming (TCP and UDP protocols)
    \item Support multi-user video conferencing with simultaneous video streams from up to 10 participants
    \item Provide multi-user audio conferencing with server-side audio mixing
    \item Enable screen/slide sharing functionality with presenter controls
    \item Facilitate group text chat with message history and private messaging capabilities
    \item Support file sharing between users with progress tracking and metadata display
    \item Ensure low latency for real-time communication (audio/video)
    \item Provide an intuitive graphical user interface for ease of use
    \item Manage user sessions gracefully, handling connections and disconnections
    \item Optimize for performance considering bandwidth and CPU usage
\end{enumerate}

The solution must be developed from scratch using socket programming principles, demonstrating deep understanding of network protocols, concurrent programming, multimedia streaming, and distributed system design.

\section{Project Scope and Objectives}

\subsection{Core Objectives}

The primary objectives of this project are:

\begin{enumerate}[itemsep=5pt]
    \item \textbf{Network Communication:}
    \begin{itemize}
        \item Implement client-server architecture using Python socket programming
        \item Design and implement custom application-layer protocols for different features
        \item Utilize UDP for real-time video and audio streaming (prioritizing low latency)
        \item Utilize TCP for control messages, chat, and file transfers (ensuring reliability)
    \end{itemize}
    
    \item \textbf{Video Conferencing:}
    \begin{itemize}
        \item Capture video from webcam using OpenCV
        \item Compress video frames using JPEG encoding (quality-bandwidth balance)
        \item Transmit video streams via UDP with minimal latency
        \item Display multiple video feeds simultaneously in a dynamic grid layout
    \end{itemize}
    
    \item \textbf{Audio Conferencing:}
    \begin{itemize}
        \item Capture audio from microphone using PyAudio
        \item Implement server-side audio mixing to combine multiple audio streams
        \item Handle jitter buffering for smooth playback
        \item Provide individual microphone and speaker controls
    \end{itemize}
    
    \item \textbf{Screen Sharing:}
    \begin{itemize}
        \item Capture full screen using MSS (Multi-Screen Shot) library
        \item Implement presenter request/grant mechanism
        \item Broadcast screen content to all participants
        \item Optimize resolution and frame rate for bandwidth efficiency
    \end{itemize}
    
    \item \textbf{Text Chat:}
    \begin{itemize}
        \item Enable group messaging to all participants
        \item Support private messaging to selected individuals
        \item Maintain server-side chat history
        \item Implement real-time message notifications
    \end{itemize}
    
    \item \textbf{File Sharing:}
    \begin{itemize}
        \item Allow file upload to server (up to 100 MB)
        \item Implement chunked transfer for reliability and progress tracking
        \item Enable file download for all participants
        \item Display file metadata (name, size, uploader, timestamp)
    \end{itemize}
\end{enumerate}

\subsection{Scope Limitations}

While comprehensive, this project has defined boundaries:

\begin{itemize}[itemsep=5pt]
    \item \textbf{Network Scope:} The application operates exclusively on LAN; no internet connectivity required or supported
    \item \textbf{User Capacity:} Maximum of 10 concurrent users (configurable, but optimized for this limit)
    \item \textbf{Security:} No encryption implemented; suitable for trusted, isolated networks only
    \item \textbf{Platform:} Developed and tested primarily on Windows 10/11; cross-platform compatibility is a goal but not guaranteed
    \item \textbf{File Storage:} Files stored in server memory during session; no persistent storage across server restarts
    \item \textbf{Recording:} No built-in recording functionality for video/audio sessions
\end{itemize}

\section{Technologies and Tools}

\subsection{Programming Language and Framework}

\textbf{Python 3.8+} was selected as the primary programming language for several reasons:

\begin{itemize}[itemsep=5pt]
    \item Excellent socket programming support with low-level control
    \item Rich ecosystem of libraries for multimedia, networking, and GUI development
    \item Cross-platform compatibility (Windows, Linux, macOS)
    \item Rapid development and prototyping capabilities
    \item Strong community support and extensive documentation
\end{itemize}

\subsection{Key Libraries and Dependencies}

The application leverages the following Python libraries:

\begin{table}[H]
\centering
\caption{Python Libraries and Their Purposes}
\label{tab:libraries}
\begin{tabular}{lll}
\toprule
\textbf{Library} & \textbf{Purpose} & \textbf{Version} \\
\midrule
\texttt{socket} & Low-level network communication (TCP/UDP) & Built-in \\
\texttt{threading} & Concurrent operations and multithreading & Built-in \\
\texttt{opencv-python} & Video capture, processing, and encoding & 4.8.1.78 \\
\texttt{numpy} & Numerical operations for audio/video processing & 1.24.3 \\
\texttt{pyaudio} & Audio capture and playback & 0.2.14 \\
\texttt{PyQt6} & Modern GUI framework & 6.6.0 \\
\texttt{Pillow} & Image processing and manipulation & 10.0.0 \\
\texttt{mss} & Fast screen capture for screen sharing & 9.0.1 \\
\texttt{qt-material} & Material Design theming for PyQt6 & 2.14 \\
\texttt{qtawesome} & Icon library for GUI & 1.3.1 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Development Environment}

\begin{itemize}[itemsep=5pt]
    \item \textbf{IDE:} Visual Studio Code with Python extensions
    \item \textbf{Version Control:} Git and GitHub for source code management
    \item \textbf{Testing Environment:} Windows 10/11 on Gigabit Ethernet LAN
    \item \textbf{Deployment:} PyInstaller for creating standalone executables
\end{itemize}

\section{Report Organization}

This technical report is organized into the following chapters:

\begin{itemize}[itemsep=5pt]
    \item \textbf{Chapter 2: System Architecture} - Detailed description of the client-server architecture, component design, and system overview
    
    \item \textbf{Chapter 3: Communication Protocols} - In-depth explanation of the custom protocols designed for each feature, including message formats and data flow
    
    \item \textbf{Chapter 4: Video Conferencing Module} - Implementation details of video capture, compression, transmission, and rendering
    
    \item \textbf{Chapter 5: Audio Conferencing Module} - Audio processing, mixing algorithms, and synchronization mechanisms
    
    \item \textbf{Chapter 6: Screen Sharing Module} - Screen capture, presenter management, and broadcast mechanisms
    
    \item \textbf{Chapter 7: Chat Module} - Text messaging implementation, chat history, and notifications
    
    \item \textbf{Chapter 8: File Sharing Module} - File transfer protocols, chunked transmission, and storage management
    
    \item \textbf{Chapter 9: User Interface Design} - GUI implementation, user experience considerations, and interface components
    
    \item \textbf{Chapter 10: Performance Analysis} - Benchmarking results, latency measurements, bandwidth analysis, and scalability evaluation
    
    \item \textbf{Chapter 11: Installation and Setup Guide} - Step-by-step instructions for deploying and configuring the application
    
    \item \textbf{Chapter 12: User Guide} - Comprehensive guide for end-users covering all features and functionality
    
    \item \textbf{Chapter 13: Testing and Validation} - Test cases, results, and validation of system requirements
    
    \item \textbf{Chapter 14: Conclusion and Future Work} - Summary of achievements, limitations, and potential enhancements
\end{itemize}

% ============================================================================
% CHAPTER 2: SYSTEM ARCHITECTURE
% ============================================================================
\chapter{System Architecture}

\section{Overview}

The LAN-based multi-user communication application follows a centralized client-server architecture where a single server instance manages all communication, coordination, and data relay between multiple client instances. This architecture was chosen for several reasons:

\begin{itemize}[itemsep=5pt]
    \item \textbf{Simplified Coordination:} A central server simplifies user session management, message broadcasting, and resource allocation
    \item \textbf{Efficient Resource Utilization:} Server-side audio mixing and video broadcasting reduce bandwidth requirements compared to peer-to-peer mesh networks
    \item \textbf{Scalability:} Easier to scale and manage compared to fully distributed architectures
    \item \textbf{Control:} Centralized control enables features like presenter management and chat history
\end{itemize}

\begin{figure}[H]
    \centering
    \begin{tabular}{c}
        \toprule
        \textbf{CLIENT 1} \\
        \midrule
        Camera | Microphone | Screen \\
        $\downarrow$ \\
        Video/Audio/Screen Capture \\
        $\downarrow$ \\
        JPEG Compression \\
        \midrule
        \multicolumn{1}{c}{TCP (5000) $\leftrightarrow$ Control/Chat} \\
        \multicolumn{1}{c}{UDP (5001) $\rightarrow$ Video Frames} \\
        \multicolumn{1}{c}{UDP (5002) $\rightarrow$ Audio Chunks} \\
        \multicolumn{1}{c}{TCP (5005) $\leftrightarrow$ Files} \\
        \bottomrule
    \end{tabular}
    \quad
    \begin{tabular}{c}
        \toprule
        \textbf{SERVER} \\
        \midrule
        TCP Port 5000 (Control/Chat) \\
        UDP Port 5001 (Video) \\
        UDP Port 5002 (Audio) \\
        TCP Port 5003 (Screen Ctrl) \\
        UDP Port 5004 (Screen Data) \\
        TCP Port 5005 (Files) \\
        \midrule
        Video Broadcaster \\
        Audio Mixer \\
        Screen Relay \\
        Chat Manager \\
        File Storage \\
        \bottomrule
    \end{tabular}
    \quad
    \begin{tabular}{c}
        \toprule
        \textbf{CLIENT 2...N} \\
        \midrule
        $\leftarrow$ UDP (5001) Video Streams \\
        $\leftarrow$ UDP (5002) Mixed Audio \\
        $\leftarrow$ UDP (5004) Screen Data \\
        $\leftrightarrow$ TCP (5000) Chat \\
        $\leftrightarrow$ TCP (5005) Files \\
        \midrule
        JPEG Decompression \\
        $\downarrow$ \\
        Video Grid Display \\
        Audio Playback \\
        Chat/File UI \\
        \bottomrule
    \end{tabular}
    \caption{High-level System Architecture}
    \label{fig:architecture}
\end{figure}

\section{Network Architecture}

\subsection{Protocol Distribution}

The application uses both TCP and UDP protocols strategically based on the requirements of each feature:

\begin{table}[H]
\centering
\caption{Network Protocol Distribution}
\label{tab:protocol-distribution}
\begin{tabular}{llll}
\toprule
\textbf{Feature} & \textbf{Purpose} & \textbf{Protocol} & \textbf{Port} \\
\midrule
Control Messages & User connection, session management & TCP & 5000 \\
Video Streaming & Real-time video frame transmission & UDP & 5001 \\
Audio Streaming & Real-time audio chunk transmission & UDP & 5002 \\
Screen Share Control & Presenter request/grant commands & TCP & 5003 \\
Screen Share Data & Screen frame transmission & UDP & 5004 \\
File Transfer & File upload/download operations & TCP & 5005 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Protocol Selection Rationale}

\textbf{TCP (Transmission Control Protocol)} is used for:
\begin{itemize}[itemsep=5pt]
    \item \textbf{Control Messages:} Reliability is essential for user authentication, session management, and state synchronization
    \item \textbf{Chat Messages:} Guaranteed delivery ensures no messages are lost
    \item \textbf{File Transfers:} Files must be transmitted completely and without errors
    \item \textbf{Screen Share Control:} Presenter commands must be reliably delivered
\end{itemize}

\textbf{UDP (User Datagram Protocol)} is used for:
\begin{itemize}[itemsep=5pt]
    \item \textbf{Video Streaming:} Low latency is prioritized over reliability; occasional frame loss is acceptable
    \item \textbf{Audio Streaming:} Real-time delivery is critical; retransmission would cause more disruption than packet loss
    \item \textbf{Screen Frames:} Similar to video, low latency is preferred for responsive screen sharing
\end{itemize}

\section{Server Architecture}

\subsection{Server Components}

The server application consists of several key components operating concurrently:

\begin{figure}[H]
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Component} & \textbf{Port} & \textbf{Function} \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\cellcolor{gray!30}\textbf{MAIN SERVER PROCESS}} \\
        \hline
        TCP Control Server & 5000 & Client connections, chat, user list \\
        \hline
        UDP Video Server & 5001 & Receive \& broadcast video frames \\
        \hline
        UDP Audio Server & 5002 & Receive, mix, \& broadcast audio \\
        \hline
        TCP Screen Control & 5003 & Presenter role management \\
        \hline
        UDP Screen Data & 5004 & Screen frame relay \\
        \hline
        TCP File Transfer & 5005 & Upload/download file handling \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\cellcolor{gray!30}\textbf{DATA STRUCTURES}} \\
        \hline
        \texttt{clients\{id: info\}} & - & User info, sockets, status \\
        \hline
        \texttt{shared\_files\{id: data\}} & - & In-memory file storage \\
        \hline
        \texttt{chat\_history[]} & - & Recent 50 messages \\
        \hline
        \texttt{presenter\_id} & - & Current screen share presenter \\
        \hline
        \hline
        \multicolumn{3}{|c|}{\cellcolor{gray!30}\textbf{THREADS}} \\
        \hline
        Main Loop & - & Accept new connections \\
        \hline
        Per-Client Handler & - & Process control messages \\
        \hline
        Video Broadcaster & - & Forward video frames \\
        \hline
        Audio Mixer & - & Mix \& broadcast audio \\
        \hline
        Screen Relay & - & Forward screen frames \\
        \hline
        File Transfer Handler & - & Per-file upload/download \\
        \hline
    \end{tabular}
    \caption{Server Component Architecture}
    \label{fig:server-components}
\end{figure}

\begin{enumerate}[itemsep=5pt]
    \item \textbf{TCP Control Server} (Port 5000)
    \begin{itemize}
        \item Accepts incoming client connections
        \item Manages user authentication and session establishment
        \item Handles control messages and chat messages
        \item Maintains user state and metadata
    \end{itemize}
    
    \item \textbf{UDP Video Server} (Port 5001)
    \begin{itemize}
        \item Receives video frames from clients
        \item Stores latest frame per client
        \item Broadcasts frames to all other clients
        \item Maps UDP addresses to client IDs
    \end{itemize}
    
    \item \textbf{UDP Audio Server} (Port 5002)
    \begin{itemize}
        \item Receives audio chunks from all clients
        \item Performs real-time audio mixing (NumPy operations)
        \item Broadcasts mixed audio to all clients
        \item Implements audio buffer management
    \end{itemize}
    
    \item \textbf{TCP Screen Control Server} (Port 5003)
    \begin{itemize}
        \item Manages presenter role assignment
        \item Handles presenter request/grant/release commands
        \item Ensures only one presenter at a time
        \item Broadcasts presenter status changes
    \end{itemize}
    
    \item \textbf{UDP Screen Data Server} (Port 5004)
    \begin{itemize}
        \item Receives screen frames from current presenter
        \item Validates presenter authorization
        \item Broadcasts screen frames to all viewers
        \item Handles presenter transitions
    \end{itemize}
    
    \item \textbf{TCP File Transfer Server} (Port 5005)
    \begin{itemize}
        \item Accepts file upload requests
        \item Stores files in memory during session
        \item Handles file download requests
        \item Manages file metadata and broadcasts availability
    \end{itemize}
\end{enumerate}

\subsection{Server Data Structures}

The server maintains several key data structures for state management:

\begin{lstlisting}[language=Python, caption=Server Data Structures, label=lst:server-data]
# Connected clients
clients = {
    client_id: {
        'tcp_conn': connection_object,
        'address': (ip, port),
        'udp_address': (ip, port),
        'audio_address': (ip, port),
        'screen_udp_address': (ip, port),
        'username': 'Alice'
    }
}

# Video frame buffer
video_frames = {
    client_id: frame_data  # Latest frame from each client
}

# Audio buffer
audio_buffers = {
    client_id: audio_chunk  # Latest audio from each client
}

# Chat history
chat_history = [
    {
        'client_id': 1,
        'username': 'Alice',
        'message': 'Hello',
        'timestamp': '14:30:25',
        'type': 'group'  # or 'private'
    }
]

# Shared files
shared_files = {
    file_id: {
        'filename': 'report.pdf',
        'size': 2621440,
        'uploader_id': 3,
        'uploader_name': 'Alice',
        'data': b'...',  # File content in memory
        'timestamp': '2025-11-05 14:30:25'
    }
}

# Presenter state
presenter_id = None  # ID of current presenter (or None)
\end{lstlisting}

\subsection{Thread Model}

The server employs multiple threads for concurrent operations:

\begin{table}[H]
\centering
\caption{Server Thread Architecture}
\label{tab:server-threads}
\begin{tabular}{ll}
\toprule
\textbf{Thread} & \textbf{Responsibility} \\
\midrule
Main Thread & Server initialization and shutdown \\
TCP Acceptor & Accept new client TCP connections \\
Client Handler (per client) & Handle individual client TCP communication \\
UDP Video Receiver & Receive and broadcast video frames \\
UDP Audio Mixer & Receive audio, mix, and broadcast \\
Screen Control Acceptor & Accept screen sharing control connections \\
Screen Handler (per presenter) & Handle presenter control commands \\
UDP Screen Receiver & Receive and broadcast screen frames \\
File Transfer Acceptor & Accept file transfer connections \\
File Transfer Handler (per transfer) & Handle individual upload/download \\
\bottomrule
\end{tabular}
\end{table}

All shared data structures are protected using thread locks to prevent race conditions:

\begin{lstlisting}[language=Python, caption=Thread Synchronization, label=lst:server-locks]
import threading

# Thread locks for shared resources
clients_lock = threading.Lock()
frames_lock = threading.Lock()
audio_lock = threading.Lock()
presenter_lock = threading.Lock()
chat_lock = threading.Lock()
files_lock = threading.Lock()

# Example usage
with clients_lock:
    for client_id, client_info in clients.items():
        # Thread-safe access to clients dictionary
        client_info['tcp_conn'].send(message)
\end{lstlisting}

\section{Client Architecture}

\subsection{Client Components}

Each client application consists of the following major components:

\begin{figure}[H]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Component} & \textbf{Description} \\
        \hline
        \hline
        \multicolumn{2}{|c|}{\cellcolor{gray!30}\textbf{NETWORK LAYER}} \\
        \hline
        TCP Control Socket & Connection to server:5000 for control/chat \\
        \hline
        UDP Video Socket & Send own video to :5001, receive others' video \\
        \hline
        UDP Audio Socket & Send own audio to :5002, receive mixed audio \\
        \hline
        TCP Screen Socket & Screen share control to :5003 \\
        \hline
        UDP Screen Socket & Screen data to/from :5004 \\
        \hline
        TCP File Socket & File transfers to :5005 \\
        \hline
        \hline
        \multicolumn{2}{|c|}{\cellcolor{gray!30}\textbf{CAPTURE MODULES}} \\
        \hline
        Video Capture (OpenCV) & Webcam capture at 640×480@30fps \\
        \hline
        Audio Capture (PyAudio) & Microphone at 44.1kHz, 16-bit, mono \\
        \hline
        Screen Capture (MSS) & Desktop capture at 960×540@10fps \\
        \hline
        \hline
        \multicolumn{2}{|c|}{\cellcolor{gray!30}\textbf{PROCESSING}} \\
        \hline
        JPEG Encoder & Compress video/screen frames (quality 60/50) \\
        \hline
        JPEG Decoder & Decompress received frames \\
        \hline
        Audio Buffer & Jitter buffer (10 chunks) for smooth playback \\
        \hline
        \hline
        \multicolumn{2}{|c|}{\cellcolor{gray!30}\textbf{GUI (PyQt6)}} \\
        \hline
        Main Window & Video grid, control bar, side panels \\
        \hline
        Video Grid & Dynamic layout for N user video feeds \\
        \hline
        Chat Panel & Message display \& input \\
        \hline
        People Panel & User list with status indicators \\
        \hline
        Files Panel & Shared files list \& upload/download \\
        \hline
        Control Bar & Video/Audio/Screen/Settings buttons \\
        \hline
        \hline
        \multicolumn{2}{|c|}{\cellcolor{gray!30}\textbf{THREADS}} \\
        \hline
        Main GUI Thread & Event loop, user interaction \\
        \hline
        Video Capture Thread & Capture \& send video frames \\
        \hline
        Audio Capture Thread & Capture \& send audio chunks \\
        \hline
        Video Receive Thread & Receive \& decode video frames \\
        \hline
        Audio Receive Thread & Receive audio \& fill jitter buffer \\
        \hline
        Audio Playback Thread & Play audio from jitter buffer \\
        \hline
        Screen Capture Thread & Capture \& send screen (when presenter) \\
        \hline
        Screen Receive Thread & Receive \& display screen share \\
        \hline
        Control Message Thread & Handle server control messages \\
        \hline
    \end{tabular}
    \caption{Client Component Architecture}
    \label{fig:client-components}
\end{figure}

\begin{enumerate}[itemsep=5pt]
    \item \textbf{Network Communication Layer}
    \begin{itemize}
        \item TCP socket for control and chat messages
        \item UDP socket for video transmission/reception
        \item Separate UDP socket for audio transmission/reception
        \item TCP socket for screen sharing control
        \item UDP socket for screen frame transmission/reception
        \item TCP socket for file transfers
    \end{itemize}
    
    \item \textbf{Video Module}
    \begin{itemize}
        \item Capture thread: Reads from webcam
        \item Compression: JPEG encoding
        \item Transmission: Sends via UDP
        \item Reception thread: Receives frames from server
        \item Display: Updates GUI with video feeds
    \end{itemize}
    
    \item \textbf{Audio Module}
    \begin{itemize}
        \item Capture thread: Records from microphone
        \item Transmission: Sends raw PCM via UDP
        \item Reception thread: Receives mixed audio
        \item Jitter buffer: Queue for smooth playback
        \item Playback thread: Outputs to speakers
    \end{itemize}
    
    \item \textbf{Screen Sharing Module}
    \begin{itemize}
        \item Control connection: Request/release presenter role
        \item Capture thread: Screenshots entire screen
        \item Transmission: Sends compressed frames
        \item Reception: Displays presenter's screen
    \end{itemize}
    
    \item \textbf{Chat Module}
    \begin{itemize}
        \item Message composition and formatting
        \item TCP transmission of chat messages
        \item Reception and display of incoming messages
        \item Notification system
    \end{itemize}
    
    \item \textbf{File Sharing Module}
    \begin{itemize}
        \item File selection dialogs
        \item Upload: Chunked file transmission
        \item Download: Receive files with progress tracking
        \item File list management
    \end{itemize}
    
    \item \textbf{Graphical User Interface}
    \begin{itemize}
        \item Main window with video grid
        \item Control panels (bottom bar)
        \item Side panels (chat, files, people)
        \item Notifications and dialogs
    \end{itemize}
\end{enumerate}

\subsection{Client Thread Model}

The client application uses multiple threads for responsive operation:

\begin{table}[H]
\centering
\caption{Client Thread Architecture}
\label{tab:client-threads}
\begin{tabular}{ll}
\toprule
\textbf{Thread} & \textbf{Responsibility} \\
\midrule
Main/GUI Thread & User interface rendering and event handling (PyQt6) \\
TCP Message Handler & Receive and process control/chat messages \\
Video Capture Thread & Capture frames from webcam and transmit \\
Video Receive Thread & Receive video streams from server \\
Audio Capture Thread & Capture audio from microphone and transmit \\
Audio Receive Thread & Receive mixed audio from server \\
Audio Playback Thread & Play audio through speakers with jitter buffer \\
Screen Capture Thread & Capture and transmit screen (when presenting) \\
Screen Receive Thread & Receive presenter's screen frames \\
File Upload Thread & Handle file upload with progress \\
File Download Thread & Handle file download with progress \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Client State Management}

The client maintains state information:

\begin{lstlisting}[language=Python, caption=Client State Variables, label=lst:client-state]
# Connection state
client_id = None
username = None
server_address = "192.168.1.100"
connected = False

# Media state
capturing = False  # Video capture active
audio_capturing = False
audio_playing = False

# Video streams from other users
video_streams = {
    client_id: frame  # Latest frame from each user
}

# Audio jitter buffer
audio_buffer = queue.Queue(maxsize=20)

# User list
users = {
    user_id: {
        'username': 'Alice',
        'video_active': True,
        'audio_active': True
    }
}

# Screen sharing state
is_presenting = False
current_presenter_id = None
shared_screen_frame = None

# File list
shared_files_metadata = {
    file_id: {
        'filename': 'report.pdf',
        'size': 2621440,
        'uploader': 'Alice',
        'uploader_id': 3
    }
}
\end{lstlisting}

\section{Communication Flow}

\subsection{Connection Establishment}

The process of a client connecting to the server:

\begin{enumerate}[itemsep=5pt]
    \item Client launches and displays connection dialog
    \item User enters server IP address and username
    \item Client creates TCP socket and connects to server:5000
    \item Client sends: \texttt{CONNECT:<username>}
    \item Server assigns unique client ID
    \item Server responds: \texttt{ID:<client\_id>}
    \item Server broadcasts updated user list to all clients
    \item Server sends chat history to new client
    \item Server sends file list to new client
    \item Client transitions to main conference interface
\end{enumerate}

\begin{figure}[H]
    \centering
    \begin{tabular}{r l l}
        \textbf{Client} & & \textbf{Server} \\
        \hline
        & & \\
        Connect to :5000 & $\xrightarrow{\text{TCP SYN}}$ & \\
        & $\xleftarrow{\text{TCP ACK}}$ & Accept connection \\
        & & \\
        \texttt{JOIN:username} & $\xrightarrow{\text{TCP}}$ & \\
        & & Generate client\_id \\
        & & Add to clients\{\} \\
        & $\xleftarrow{\text{TCP}}$ & \texttt{WELCOME:client\_id} \\
        Store client\_id & & \\
        & $\xleftarrow{\text{TCP}}$ & \texttt{USER\_LIST:\{users\}} \\
        Update user list & & \\
        & $\xleftarrow{\text{TCP}}$ & \texttt{CHAT\_HISTORY:[msgs]} \\
        Load chat history & & \\
        & & Broadcast to all: \\
        & $\xleftarrow{\text{TCP}}$ & \texttt{USER\_JOINED:new\_user} \\
        Update UI & & \\
        & & \\
        Bind UDP :5001 & & \\
        Bind UDP :5002 & & \\
        & & \\
        Start video capture & & \\
        Compress frame (JPEG) & & \\
        & $\xrightarrow{\text{UDP :5001}}$ & Receive video frame \\
        & & Broadcast to all clients \\
        & $\xleftarrow{\text{UDP :5001}}$ & Other users' frames \\
        Decode \& display & & \\
        & & \\
        \multicolumn{3}{c}{\textit{[Similar flow for audio, screen, chat, files...]}} \\
    \end{tabular}
    \caption{Connection Establishment Sequence}
    \label{fig:connection-sequence}
\end{figure}

\subsection{Data Flow Patterns}

The application employs several data flow patterns:

\begin{enumerate}[itemsep=5pt]
    \item \textbf{Unicast} (Point-to-point)
    \begin{itemize}
        \item File transfers (client $\leftrightarrow$ server)
        \item Private chat messages
        \item Presenter control commands
    \end{itemize}
    
    \item \textbf{Broadcast} (Server to all clients)
    \begin{itemize}
        \item Video frames from each user
        \item Mixed audio stream
        \item Screen sharing frames
        \item Group chat messages
        \item User list updates
        \item File availability notifications
    \end{itemize}
    
    \item \textbf{Aggregation} (Multiple clients to server)
    \begin{itemize}
        \item Video frames (collected and redistributed)
        \item Audio streams (mixed together)
        \item Chat messages (stored and broadcast)
    \end{itemize}
\end{enumerate}

% End of Chapter 2

% ============================================================================
% CHAPTER 3: COMMUNICATION PROTOCOLS
% ============================================================================
\chapter{Communication Protocols}

\section{Protocol Message Format}

All text-based protocol messages follow a structured format for easy parsing and extensibility.

\subsection{General Message Structure}

Text messages use a colon-separated format:
\begin{lstlisting}[language=bash, caption=Message Format, label=lst:message-format]
MESSAGE_TYPE:param1:param2:param3...
\end{lstlisting}

Binary messages (video, audio, screen frames) use:
\begin{lstlisting}[language=bash, caption=Binary Message Format, label=lst:binary-format]
[client_id (4 bytes)][data_length (4 bytes)][data (variable)]
\end{lstlisting}

\section{Control Protocol (TCP Port 5000)}

\subsection{Connection Messages}

\begin{table}[H]
\centering
\caption{Connection Protocol Messages}
\label{tab:connection-messages}
\begin{tabular}{lll}
\toprule
\textbf{Message} & \textbf{Direction} & \textbf{Description} \\
\midrule
\texttt{CONNECT:<username>} & Client → Server & Request connection with username \\
\texttt{ID:<client\_id>} & Server → Client & Assign unique client ID \\
\texttt{USER\_JOINED:<id>:<name>} & Server → All & Notify user joined \\
\texttt{USER\_LEFT:<id>} & Server → All & Notify user disconnected \\
\texttt{DISCONNECT} & Client → Server & Graceful disconnect \\
\bottomrule
\end{tabular}
\end{table}

\subsection{User List Protocol}

After connection, the server sends the complete user list:

\begin{lstlisting}[language=bash, caption=User List Message, label=lst:userlist]
USER_LIST:<id1>:<name1>:<id2>:<name2>:...
\end{lstlisting}

Example:
\begin{lstlisting}[language=bash]
USER_LIST:1:Alice:2:Bob:3:Charlie
\end{lstlisting}

\subsection{Media Control Messages}

\begin{table}[H]
\centering
\caption{Media Control Messages}
\label{tab:media-control}
\begin{tabular}{lll}
\toprule
\textbf{Message} & \textbf{Direction} & \textbf{Description} \\
\midrule
\texttt{VIDEO\_START} & Client → Server & Client started video \\
\texttt{VIDEO\_STOP} & Client → Server & Client stopped video \\
\texttt{AUDIO\_START} & Client → Server & Client started audio \\
\texttt{AUDIO\_STOP} & Client → Server & Client stopped audio \\
\texttt{USER\_VIDEO:<id>:<status>} & Server → All & Broadcast video status \\
\texttt{USER\_AUDIO:<id>:<status>} & Server → All & Broadcast audio status \\
\bottomrule
\end{tabular}
\end{table}

\section{Video Protocol (UDP Port 5001)}

\subsection{Video Frame Format}

Each video frame is transmitted as:

\begin{table}[H]
\centering
\caption{Video Frame Structure}
\label{tab:video-frame}
\begin{tabular}{lll}
\toprule
\textbf{Field} & \textbf{Size} & \textbf{Description} \\
\midrule
Client ID & 4 bytes & Sender's client ID (big-endian) \\
Frame Length & 4 bytes & JPEG data length (big-endian) \\
Frame Data & Variable & JPEG compressed image data \\
\bottomrule
\end{tabular}
\end{table}

\begin{lstlisting}[language=Python, caption=Video Frame Encoding, label=lst:video-encode]
# Client-side: Encode and send video frame
ret, frame = cap.read()  # Capture from webcam
_, buffer = cv2.imencode('.jpg', frame, 
    [cv2.IMWRITE_JPEG_QUALITY, 60])  # Compress to JPEG

frame_data = buffer.tobytes()
frame_length = len(frame_data)

# Create packet: [client_id][length][data]
packet = struct.pack('>I', client_id) + \
         struct.pack('>I', frame_length) + \
         frame_data

video_socket.sendto(packet, (server_ip, 5001))
\end{lstlisting}

\begin{lstlisting}[language=Python, caption=Video Frame Decoding, label=lst:video-decode]
# Server-side: Receive and broadcast
data, addr = video_socket.recvfrom(65536)  # Max UDP packet

# Parse packet
client_id = struct.unpack('>I', data[0:4])[0]
frame_length = struct.unpack('>I', data[4:8])[0]
frame_data = data[8:8+frame_length]

# Store latest frame
video_frames[client_id] = frame_data

# Broadcast to all other clients
for other_id, client_info in clients.items():
    if other_id != client_id:
        video_socket.sendto(data, client_info['udp_address'])
\end{lstlisting}

\subsection{Video Parameters}

\begin{table}[H]
\centering
\caption{Video Transmission Parameters}
\label{tab:video-params}
\begin{tabular}{ll}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Resolution & 640 × 480 pixels \\
Frame Rate & 30 FPS (target) \\
Compression & JPEG, Quality 60 \\
Protocol & UDP (unreliable, low latency) \\
Typical Frame Size & 15-25 KB \\
Bandwidth (per stream) & $\approx$ 4-6 Mbps \\
\bottomrule
\end{tabular}
\end{table}

\section{Audio Protocol (UDP Port 5002)}

\subsection{Audio Chunk Format}

Audio data is transmitted in small chunks:

\begin{table}[H]
\centering
\caption{Audio Chunk Structure}
\label{tab:audio-chunk}
\begin{tabular}{lll}
\toprule
\textbf{Field} & \textbf{Size} & \textbf{Description} \\
\midrule
Client ID & 4 bytes & Sender's client ID (big-endian) \\
Chunk Length & 4 bytes & Audio data length (big-endian) \\
Audio Data & Variable & Raw PCM samples (int16) \\
\bottomrule
\end{tabular}
\end{table}

\begin{lstlisting}[language=Python, caption=Audio Chunk Transmission, label=lst:audio-send]
# Client-side: Capture and send audio
CHUNK_SIZE = 1024  # Samples per chunk
audio_data = stream.read(CHUNK_SIZE)  # Read from microphone

# Create packet: [client_id][length][pcm_data]
packet = struct.pack('>I', client_id) + \
         struct.pack('>I', len(audio_data)) + \
         audio_data

audio_socket.sendto(packet, (server_ip, 5002))
\end{lstlisting}

\begin{lstlisting}[language=Python, caption=Audio Mixing Algorithm, label=lst:audio-mix]
# Server-side: Mix audio from all clients
def mix_audio(audio_buffers):
    """Mix multiple audio streams using NumPy"""
    if not audio_buffers:
        return None
    
    # Convert all chunks to NumPy arrays
    arrays = []
    for client_id, audio_data in audio_buffers.items():
        arr = np.frombuffer(audio_data, dtype=np.int16)
        arrays.append(arr)
    
    # Ensure all same length (pad if needed)
    max_len = max(len(arr) for arr in arrays)
    padded = [np.pad(arr, (0, max_len - len(arr))) 
              for arr in arrays]
    
    # Average mixing (prevent clipping)
    mixed = np.mean(padded, axis=0).astype(np.int16)
    
    return mixed.tobytes()

# Broadcast mixed audio to all clients
mixed_audio = mix_audio(audio_buffers)
for client_id, client_info in clients.items():
    audio_socket.sendto(mixed_audio, 
                       client_info['audio_address'])
\end{lstlisting}

\subsection{Audio Parameters}

\begin{table}[H]
\centering
\caption{Audio Transmission Parameters}
\label{tab:audio-params}
\begin{tabular}{ll}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Sample Rate & 44100 Hz \\
Bit Depth & 16 bits \\
Channels & 1 (Mono) \\
Chunk Size & 1024 samples \\
Chunk Duration & $\approx$ 23 ms \\
Chunk Size (bytes) & 2048 bytes \\
Protocol & UDP (unreliable, low latency) \\
Bandwidth (per stream) & $\approx$ 705 Kbps \\
Jitter Buffer Size & 20 chunks ($\approx$ 460 ms) \\
\bottomrule
\end{tabular}
\end{table}

\section{Chat Protocol (TCP Port 5000)}

Chat messages are sent over the main TCP control connection.

\subsection{Chat Message Types}

\begin{table}[H]
\centering
\caption{Chat Protocol Messages}
\label{tab:chat-messages}
\begin{tabular}{lll}
\toprule
\textbf{Message} & \textbf{Direction} & \textbf{Description} \\
\midrule
\texttt{CHAT:<msg>} & Client → Server & Send group chat message \\
\texttt{PRIVATE:<target\_id>:<msg>} & Client → Server & Send private message \\
\texttt{CHAT:<id>:<name>:<msg>:<time>} & Server → All & Broadcast group message \\
\texttt{PRIVATE:<from\_id>:<name>:<msg>:<time>} & Server → Target & Forward private message \\
\texttt{CHAT\_HISTORY:<history>} & Server → Client & Send chat history on join \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Chat History Format}

When a client connects, the server sends recent chat history:

\begin{lstlisting}[language=bash, caption=Chat History Message, label=lst:chat-history]
CHAT_HISTORY:[msg1]|[msg2]|[msg3]...

# Each message format:
[type]:[sender_id]:[sender_name]:[message]:[timestamp]

# Example:
CHAT_HISTORY:group:1:Alice:Hello everyone!:14:30:25|private:2:Bob:Hi Alice:14:31:10
\end{lstlisting}

\section{Screen Sharing Protocol}

Screen sharing uses two connections: TCP for control and UDP for data.

\subsection{Control Protocol (TCP Port 5003)}

\begin{table}[H]
\centering
\caption{Screen Sharing Control Messages}
\label{tab:screen-control}
\begin{tabular}{lll}
\toprule
\textbf{Message} & \textbf{Direction} & \textbf{Description} \\
\midrule
\texttt{REQUEST\_PRESENTER} & Client → Server & Request to become presenter \\
\texttt{PRESENTER\_GRANTED} & Server → Client & Request approved \\
\texttt{PRESENTER\_DENIED} & Server → Client & Request denied (already presenting) \\
\texttt{STOP\_PRESENTING} & Client → Server & Release presenter role \\
\texttt{PRESENTER\_STARTED:<id>:<name>} & Server → All & Notify presentation started \\
\texttt{PRESENTER\_STOPPED} & Server → All & Notify presentation ended \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Screen Data Protocol (UDP Port 5004)}

Screen frames use the same format as video frames:

\begin{lstlisting}[language=Python, caption=Screen Frame Transmission, label=lst:screen-send]
# Capture screen (MSS library)
with mss.mss() as sct:
    monitor = sct.monitors[1]  # Primary monitor
    screenshot = sct.grab(monitor)
    
    # Convert to NumPy array
    frame = np.array(screenshot)
    
    # Resize to reduce bandwidth (960x540)
    frame = cv2.resize(frame, (960, 540))
    
    # Compress to JPEG (quality 50)
    _, buffer = cv2.imencode('.jpg', frame,
        [cv2.IMWRITE_JPEG_QUALITY, 50])
    
    # Send packet
    frame_data = buffer.tobytes()
    packet = struct.pack('>I', client_id) + \
             struct.pack('>I', len(frame_data)) + \
             frame_data
    
    screen_socket.sendto(packet, (server_ip, 5004))
\end{lstlisting}

\subsection{Screen Sharing Parameters}

\begin{table}[H]
\centering
\caption{Screen Sharing Parameters}
\label{tab:screen-params}
\begin{tabular}{ll}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Resolution & 960 × 540 pixels \\
Frame Rate & 10 FPS \\
Compression & JPEG, Quality 50 \\
Protocol & UDP for data, TCP for control \\
Typical Frame Size & 30-50 KB \\
Bandwidth & $\approx$ 2.4-4 Mbps \\
Presenter Limit & 1 at a time \\
\bottomrule
\end{tabular}
\end{table}

\section{File Transfer Protocol (TCP Port 5005)}

\subsection{File Upload Process}

\begin{enumerate}[itemsep=5pt]
    \item Client sends: \texttt{UPLOAD:<filename>:<filesize>}
    \item Server responds: \texttt{UPLOAD\_READY:<file\_id>}
    \item Client sends file in 8 KB chunks
    \item Server acknowledges each chunk: \texttt{CHUNK\_ACK}
    \item After all chunks: \texttt{UPLOAD\_COMPLETE}
    \item Server broadcasts to all: \texttt{FILE\_AVAILABLE:<id>:<name>:<size>:<uploader>}
\end{enumerate}

\begin{lstlisting}[language=Python, caption=File Upload Implementation, label=lst:file-upload]
# Client-side file upload
CHUNK_SIZE = 8192  # 8 KB chunks

# Initiate upload
file_size = os.path.getsize(filepath)
filename = os.path.basename(filepath)
file_socket.send(f"UPLOAD:{filename}:{file_size}".encode())

# Receive file ID
response = file_socket.recv(1024).decode()
file_id = int(response.split(':')[1])

# Send file in chunks
with open(filepath, 'rb') as f:
    total_sent = 0
    while total_sent < file_size:
        chunk = f.read(CHUNK_SIZE)
        file_socket.send(chunk)
        
        # Wait for acknowledgment
        ack = file_socket.recv(1024)
        total_sent += len(chunk)
        
        # Update progress bar
        progress = (total_sent / file_size) * 100
        update_progress(progress)

# Upload complete
completion = file_socket.recv(1024).decode()
\end{lstlisting}

\subsection{File Download Process}

\begin{enumerate}[itemsep=5pt]
    \item Client sends: \texttt{DOWNLOAD:<file\_id>}
    \item Server responds: \texttt{DOWNLOAD\_START:<filename>:<filesize>}
    \item Server sends file in 8 KB chunks
    \item Client acknowledges each chunk: \texttt{CHUNK\_ACK}
    \item After all chunks: Server sends \texttt{DOWNLOAD\_COMPLETE}
\end{enumerate}

\begin{lstlisting}[language=Python, caption=File Download Implementation, label=lst:file-download]
# Client-side file download
file_socket.send(f"DOWNLOAD:{file_id}".encode())

# Receive file metadata
response = file_socket.recv(1024).decode()
_, filename, filesize = response.split(':')
filesize = int(filesize)

# Receive file in chunks
with open(save_path, 'wb') as f:
    total_received = 0
    while total_received < filesize:
        chunk = file_socket.recv(CHUNK_SIZE)
        f.write(chunk)
        
        # Acknowledge chunk
        file_socket.send(b"CHUNK_ACK")
        total_received += len(chunk)
        
        # Update progress
        progress = (total_received / filesize) * 100
        update_progress(progress)

# Download complete
completion = file_socket.recv(1024).decode()
\end{lstlisting}

\subsection{File Transfer Parameters}

\begin{table}[H]
\centering
\caption{File Transfer Parameters}
\label{tab:file-params}
\begin{tabular}{ll}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Protocol & TCP (reliable delivery) \\
Chunk Size & 8192 bytes (8 KB) \\
Maximum File Size & 100 MB \\
Storage & In-memory during session \\
Acknowledgment & Per chunk \\
Progress Tracking & Percentage-based \\
Supported Types & All file types \\
\bottomrule
\end{tabular}
\end{table}

\section{Error Handling}

\subsection{Connection Errors}

\begin{itemize}[itemsep=5pt]
    \item \textbf{Connection refused:} Server not running or wrong IP
    \item \textbf{Connection timeout:} Network unreachable
    \item \textbf{Connection lost:} Detected via TCP socket exceptions
    \item \textbf{Duplicate username:} Server rejects and requests new username
\end{itemize}

\subsection{Media Errors}

\begin{itemize}[itemsep=5pt]
    \item \textbf{Packet loss:} UDP packets may be lost; client displays last good frame
    \item \textbf{Frame corruption:} JPEG decode errors are caught and ignored
    \item \textbf{Audio buffer underrun:} Jitter buffer prevents playback glitches
    \item \textbf{Audio buffer overrun:} Oldest packets dropped
\end{itemize}

\subsection{File Transfer Errors}

\begin{itemize}[itemsep=5pt]
    \item \textbf{File too large:} Server rejects files $>$ 100 MB
    \item \textbf{Insufficient memory:} Server rejects if memory limit reached
    \item \textbf{Transfer interrupted:} Partial files discarded, client notified
\end{itemize}

% End of Chapter 3

% ============================================================================
% CHAPTER 4: VIDEO CONFERENCING MODULE
% ============================================================================
\chapter{Video Conferencing Module}

\section{Overview}

The video conferencing module enables real-time video streaming between all connected users. Each client captures video from their webcam, compresses it, and transmits it to the server, which then broadcasts it to all other clients. The module is designed for low-latency communication while managing bandwidth efficiently.

\section{Video Capture}

\subsection{Webcam Access}

The client uses OpenCV's \texttt{VideoCapture} API to access the webcam:

\begin{lstlisting}[language=Python, caption=Video Capture Initialization, label=lst:video-init]
import cv2

# Initialize webcam (device 0 is default camera)
self.cap = cv2.VideoCapture(0)

# Set capture resolution
self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
self.cap.set(cv2.CAP_PROP_FPS, 30)

# Verify camera opened successfully
if not self.cap.isOpened():
    show_error("Failed to open webcam")
    return
\end{lstlisting}

\subsection{Capture Thread}

Video capture runs in a separate thread to prevent blocking the GUI:

\begin{lstlisting}[language=Python, caption=Video Capture Thread, label=lst:video-thread]
def capture_video(self):
    """Continuous video capture and transmission"""
    while self.capturing:
        ret, frame = self.cap.read()
        
        if not ret:
            print("Failed to capture frame")
            time.sleep(0.033)  # Wait ~30ms
            continue
        
        # Flip frame horizontally (mirror effect)
        frame = cv2.flip(frame, 1)
        
        # Display own video locally
        self.update_own_video.emit(frame)
        
        # Compress and transmit
        self.send_video_frame(frame)
        
        # Target 30 FPS
        time.sleep(0.033)
\end{lstlisting}

\section{Video Compression}

\subsection{JPEG Encoding}

Frames are compressed using JPEG to reduce bandwidth:

\begin{lstlisting}[language=Python, caption=JPEG Compression, label=lst:jpeg-compress]
def send_video_frame(self, frame):
    """Compress and send video frame via UDP"""
    try:
        # Encode frame as JPEG with quality 60
        encode_param = [cv2.IMWRITE_JPEG_QUALITY, 60]
        result, encoded_frame = cv2.imencode('.jpg', frame, 
                                             encode_param)
        
        if not result:
            return
        
        # Convert to bytes
        frame_data = encoded_frame.tobytes()
        frame_length = len(frame_data)
        
        # Create packet header
        packet = struct.pack('>I', self.client_id)  # 4 bytes
        packet += struct.pack('>I', frame_length)    # 4 bytes
        packet += frame_data
        
        # Send via UDP
        self.video_socket.sendto(packet, 
            (self.server_address, VIDEO_PORT))
        
    except Exception as e:
        print(f"Error sending video frame: {e}")
\end{lstlisting}

\subsection{Compression Analysis}

\begin{table}[H]
\centering
\caption{Video Compression Performance}
\label{tab:video-compression}
\begin{tabular}{lrrr}
\toprule
\textbf{Quality} & \textbf{Frame Size} & \textbf{Bandwidth} & \textbf{Visual Quality} \\
\midrule
90 & 45-60 KB & 10.8-14.4 Mbps & Excellent \\
80 & 35-45 KB & 8.4-10.8 Mbps & Very Good \\
70 & 25-35 KB & 6.0-8.4 Mbps & Good \\
\textbf{60} & \textbf{15-25 KB} & \textbf{3.6-6.0 Mbps} & \textbf{Good (Selected)} \\
50 & 12-18 KB & 2.9-4.3 Mbps & Acceptable \\
40 & 8-12 KB & 1.9-2.9 Mbps & Poor \\
\bottomrule
\end{tabular}
\end{table}

Quality 60 was selected as the optimal balance between visual quality and bandwidth usage.

\section{Server-Side Processing}

\subsection{Frame Reception and Storage}

The server receives frames from all clients and stores the latest frame:

\begin{lstlisting}[language=Python, caption=Server Video Reception, label=lst:server-video-rx]
def receive_video_frames(self):
    """Receive video frames from clients and broadcast"""
    while self.running:
        try:
            # Receive UDP packet (max 65536 bytes)
            data, addr = self.video_socket.recvfrom(65536)
            
            if len(data) < 8:
                continue
            
            # Parse packet header
            client_id = struct.unpack('>I', data[0:4])[0]
            frame_length = struct.unpack('>I', data[4:8])[0]
            frame_data = data[8:8+frame_length]
            
            # Validate client
            if client_id not in self.clients:
                continue
            
            # Update UDP address mapping
            with self.clients_lock:
                self.clients[client_id]['udp_address'] = addr
            
            # Store latest frame
            with self.frames_lock:
                self.video_frames[client_id] = frame_data
            
            # Broadcast to other clients
            self.broadcast_video_frame(client_id, data)
            
        except Exception as e:
            print(f"Video reception error: {e}")
\end{lstlisting}

\subsection{Frame Broadcasting}

The server broadcasts each frame to all other connected clients:

\begin{lstlisting}[language=Python, caption=Video Broadcasting, label=lst:video-broadcast]
def broadcast_video_frame(self, sender_id, frame_packet):
    """Broadcast video frame to all clients except sender"""
    with self.clients_lock:
        for client_id, client_info in self.clients.items():
            # Don't send back to sender
            if client_id == sender_id:
                continue
            
            # Check if client has established UDP connection
            if 'udp_address' not in client_info:
                continue
            
            try:
                # Send frame to client
                self.video_socket.sendto(
                    frame_packet,
                    client_info['udp_address']
                )
            except Exception as e:
                print(f"Error broadcasting to {client_id}: {e}")
\end{lstlisting}

\section{Client-Side Reception and Display}

\subsection{Frame Reception}

Clients receive video frames from other users:

\begin{lstlisting}[language=Python, caption=Client Video Reception, label=lst:client-video-rx]
def receive_video_frames(self):
    """Receive and decode video frames from server"""
    while self.capturing:
        try:
            data, _ = self.video_socket.recvfrom(65536)
            
            if len(data) < 8:
                continue
            
            # Parse packet
            sender_id = struct.unpack('>I', data[0:4])[0]
            frame_length = struct.unpack('>I', data[4:8])[0]
            frame_data = data[8:8+frame_length]
            
            # Decode JPEG
            frame_array = np.frombuffer(frame_data, 
                                       dtype=np.uint8)
            frame = cv2.imdecode(frame_array, cv2.IMREAD_COLOR)
            
            if frame is None:
                continue
            
            # Store in video streams dictionary
            self.video_streams[sender_id] = frame
            
            # Trigger GUI update
            self.update_video_grid.emit(sender_id, frame)
            
        except Exception as e:
            print(f"Error receiving video: {e}")
\end{lstlisting}

\subsection{Video Grid Display}

The GUI displays video feeds in a grid layout:

\begin{lstlisting}[language=Python, caption=Video Grid Layout, label=lst:video-grid]
def setup_video_grid(self):
    """Create grid layout for video displays"""
    self.video_grid = QGridLayout()
    self.video_labels = {}
    
    # Calculate grid dimensions based on user count
    # Max 10 users -> 4x3 grid
    
    for i in range(12):  # Support up to 12 positions
        label = QLabel()
        label.setFixedSize(320, 240)  # Half of 640x480
        label.setStyleSheet("""
            QLabel {
                background-color: #1e1e1e;
                border: 2px solid #333;
                border-radius: 8px;
            }
        """)
        label.setScaledContents(True)
        
        row = i // 4
        col = i % 4
        self.video_grid.addWidget(label, row, col)
        self.video_labels[i] = label

def update_video_display(self, user_id, frame):
    """Update video display for specific user"""
    # Convert OpenCV frame to QPixmap
    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    h, w, ch = rgb_frame.shape
    bytes_per_line = ch * w
    qt_image = QImage(rgb_frame.data, w, h, 
                     bytes_per_line, QImage.Format_RGB888)
    pixmap = QPixmap.fromImage(qt_image)
    
    # Find label position for this user
    position = self.user_positions.get(user_id)
    if position is not None:
        self.video_labels[position].setPixmap(pixmap)
\end{lstlisting}

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.9\textwidth}{\centering
        \vspace{2cm}
        \textbf{[SCREENSHOT PLACEHOLDER]}\\
        \vspace{0.5cm}
        Video Grid Display\\
        Showing multiple user video feeds in grid layout\\
        \vspace{2cm}
    }}
    \caption{Video Conferencing Interface}
    \label{fig:video-grid}
\end{figure}

\section{Video Controls}

\subsection{Start/Stop Video}

Users can toggle their video on/off:

\begin{lstlisting}[language=Python, caption=Video Toggle Control, label=lst:video-toggle]
def toggle_video(self):
    """Start or stop video capture"""
    if not self.capturing:
        # Start video
        self.capturing = True
        
        # Notify server
        self.tcp_socket.send(b"VIDEO_START")
        
        # Start capture thread
        self.video_thread = threading.Thread(
            target=self.capture_video,
            daemon=True
        )
        self.video_thread.start()
        
        # Update UI
        self.video_button.setText("Stop Video")
        self.video_button.setStyleSheet("background: #dc3545")
        
    else:
        # Stop video
        self.capturing = False
        
        # Notify server
        self.tcp_socket.send(b"VIDEO_STOP")
        
        # Release camera
        if self.cap:
            self.cap.release()
        
        # Update UI
        self.video_button.setText("Start Video")
        self.video_button.setStyleSheet("background: #28a745")
\end{lstlisting}

\section{Performance Optimization}

\subsection{Frame Rate Control}

Target frame rate is maintained using sleep timing:

\begin{lstlisting}[language=Python, caption=Frame Rate Control, label=lst:fps-control]
import time

TARGET_FPS = 30
FRAME_INTERVAL = 1.0 / TARGET_FPS  # ~0.033 seconds

def capture_video(self):
    """Capture with FPS control"""
    while self.capturing:
        start_time = time.time()
        
        # Capture and send frame
        ret, frame = self.cap.read()
        if ret:
            self.send_video_frame(frame)
        
        # Calculate sleep time to maintain FPS
        elapsed = time.time() - start_time
        sleep_time = max(0, FRAME_INTERVAL - elapsed)
        time.sleep(sleep_time)
\end{lstlisting}

\subsection{Bandwidth Management}

For networks with limited bandwidth, the system can be configured with lower quality or resolution:

\begin{table}[H]
\centering
\caption{Bandwidth Scaling Options}
\label{tab:bandwidth-options}
\begin{tabular}{lrrr}
\toprule
\textbf{Configuration} & \textbf{Resolution} & \textbf{Quality} & \textbf{Bandwidth} \\
\midrule
High Quality & 640 × 480 & 80 & 8-10 Mbps \\
\textbf{Standard (Default)} & \textbf{640 × 480} & \textbf{60} & \textbf{4-6 Mbps} \\
Low Bandwidth & 480 × 360 & 50 & 2-3 Mbps \\
Very Low & 320 × 240 & 40 & 1-2 Mbps \\
\bottomrule
\end{tabular}
\end{table}

\section{Error Handling}

\subsection{Camera Errors}

\begin{lstlisting}[language=Python, caption=Camera Error Handling, label=lst:camera-errors]
def start_video_capture(self):
    """Start video with error handling"""
    try:
        self.cap = cv2.VideoCapture(0)
        
        if not self.cap.isOpened():
            raise Exception("Cannot open webcam")
        
        # Test capture
        ret, test_frame = self.cap.read()
        if not ret:
            raise Exception("Cannot read from webcam")
        
        self.capturing = True
        self.start_capture_thread()
        
    except Exception as e:
        QMessageBox.warning(
            self,
            "Camera Error",
            f"Failed to start camera: {str(e)}\n\n"
            "Please check:\n"
            "- Camera is connected\n"
            "- Camera permissions are granted\n"
            "- No other app is using the camera"
        )
        self.capturing = False
\end{lstlisting}

\subsection{Packet Loss Handling}

UDP packet loss is handled gracefully:

\begin{itemize}[itemsep=5pt]
    \item \textbf{Lost frames:} Display last successfully received frame
    \item \textbf{Corrupted frames:} Catch JPEG decode errors and skip
    \item \textbf{No video indicator:} Show placeholder if no frames received for 5 seconds
\end{itemize}

% ============================================================================
% CHAPTER 5: AUDIO CONFERENCING MODULE
% ============================================================================
\chapter{Audio Conferencing Module}

\section{Overview}

The audio conferencing module provides real-time voice communication between all users. Unlike video where each stream is displayed separately, audio from all users is mixed together server-side and broadcast as a single stream, creating a natural conference call experience.

\section{Audio Capture}

\subsection{PyAudio Initialization}

The client uses PyAudio for audio input/output:

\begin{lstlisting}[language=Python, caption=PyAudio Initialization, label=lst:audio-init]
import pyaudio

# Audio parameters
CHUNK = 1024          # Samples per chunk
FORMAT = pyaudio.paInt16  # 16-bit PCM
CHANNELS = 1          # Mono
RATE = 44100          # Sample rate (Hz)

# Initialize PyAudio
self.audio = pyaudio.PyAudio()

# Open input stream (microphone)
self.audio_input_stream = self.audio.open(
    format=FORMAT,
    channels=CHANNELS,
    rate=RATE,
    input=True,
    frames_per_buffer=CHUNK
)

# Open output stream (speakers)
self.audio_output_stream = self.audio.open(
    format=FORMAT,
    channels=CHANNELS,
    rate=RATE,
    output=True,
    frames_per_buffer=CHUNK
)
\end{lstlisting}

\subsection{Audio Capture Thread}

Audio capture runs continuously in a dedicated thread:

\begin{lstlisting}[language=Python, caption=Audio Capture Thread, label=lst:audio-capture]
def capture_audio(self):
    """Continuously capture and transmit audio"""
    while self.audio_capturing:
        try:
            # Read audio chunk from microphone
            audio_data = self.audio_input_stream.read(
                CHUNK,
                exception_on_overflow=False
            )
            
            # Create packet
            packet = struct.pack('>I', self.client_id)
            packet += struct.pack('>I', len(audio_data))
            packet += audio_data
            
            # Send via UDP
            self.audio_socket.sendto(
                packet,
                (self.server_address, AUDIO_PORT)
            )
            
        except Exception as e:
            print(f"Audio capture error: {e}")
            time.sleep(0.001)
\end{lstlisting}

\section{Server-Side Audio Mixing}

\subsection{Audio Reception}

The server receives audio chunks from all clients:

\begin{lstlisting}[language=Python, caption=Server Audio Reception, label=lst:server-audio-rx]
def receive_audio(self):
    """Receive audio from all clients"""
    while self.running:
        try:
            data, addr = self.audio_socket.recvfrom(4096)
            
            if len(data) < 8:
                continue
            
            # Parse packet
            client_id = struct.unpack('>I', data[0:4])[0]
            audio_length = struct.unpack('>I', data[4:8])[0]
            audio_data = data[8:8+audio_length]
            
            # Update audio address
            with self.clients_lock:
                if client_id in self.clients:
                    self.clients[client_id]['audio_address'] = addr
            
            # Store audio chunk
            with self.audio_lock:
                self.audio_buffers[client_id] = audio_data
            
        except Exception as e:
            print(f"Audio reception error: {e}")
\end{lstlisting}

\subsection{Real-Time Audio Mixing}

The server mixes audio from all clients using NumPy:

\begin{lstlisting}[language=Python, caption=Audio Mixing Implementation, label=lst:audio-mixing]
import numpy as np

def mix_and_broadcast_audio(self):
    """Mix audio from all clients and broadcast"""
    while self.running:
        try:
            with self.audio_lock:
                if len(self.audio_buffers) == 0:
                    time.sleep(0.001)
                    continue
                
                # Copy current buffers
                buffers_copy = self.audio_buffers.copy()
                self.audio_buffers.clear()
            
            # Convert all audio chunks to NumPy arrays
            audio_arrays = []
            for client_id, audio_data in buffers_copy.items():
                arr = np.frombuffer(audio_data, dtype=np.int16)
                audio_arrays.append(arr)
            
            if not audio_arrays:
                continue
            
            # Find maximum length
            max_length = max(len(arr) for arr in audio_arrays)
            
            # Pad shorter arrays with zeros
            padded_arrays = []
            for arr in audio_arrays:
                if len(arr) < max_length:
                    padded = np.pad(arr, 
                        (0, max_length - len(arr)),
                        mode='constant'
                    )
                    padded_arrays.append(padded)
                else:
                    padded_arrays.append(arr)
            
            # Mix using averaging (prevents clipping)
            mixed = np.mean(padded_arrays, axis=0).astype(np.int16)
            mixed_data = mixed.tobytes()
            
            # Broadcast to all clients
            self.broadcast_audio(mixed_data)
            
        except Exception as e:
            print(f"Audio mixing error: {e}")
            time.sleep(0.001)

def broadcast_audio(self, mixed_audio):
    """Broadcast mixed audio to all clients"""
    with self.clients_lock:
        for client_id, client_info in self.clients.items():
            if 'audio_address' not in client_info:
                continue
            
            try:
                self.audio_socket.sendto(
                    mixed_audio,
                    client_info['audio_address']
                )
            except Exception as e:
                print(f"Audio broadcast error: {e}")
\end{lstlisting}

\subsection{Mixing Algorithm Analysis}

The averaging method prevents clipping while maintaining audio quality:

\begin{equation}
\text{mixed}[i] = \frac{1}{N} \sum_{j=1}^{N} \text{audio}_j[i]
\end{equation}

Where $N$ is the number of active audio streams.

\textbf{Alternative: Simple Addition (not used)}
\begin{equation}
\text{mixed}[i] = \sum_{j=1}^{N} \text{audio}_j[i]
\end{equation}

This can cause clipping when $N$ is large, resulting in audio distortion.

\section{Client-Side Audio Playback}

\subsection{Audio Reception with Jitter Buffer}

The client uses a jitter buffer to smooth playback:

\begin{lstlisting}[language=Python, caption=Audio Reception with Jitter Buffer, label=lst:audio-jitter]
import queue

# Jitter buffer (FIFO queue)
self.audio_buffer = queue.Queue(maxsize=20)

def receive_audio(self):
    """Receive audio from server and buffer"""
    while self.audio_capturing:
        try:
            # Receive mixed audio from server
            audio_data, _ = self.audio_socket.recvfrom(4096)
            
            # Add to jitter buffer
            if not self.audio_buffer.full():
                self.audio_buffer.put(audio_data)
            else:
                # Buffer full - drop oldest
                try:
                    self.audio_buffer.get_nowait()
                    self.audio_buffer.put(audio_data)
                except:
                    pass
                    
        except Exception as e:
            print(f"Audio reception error: {e}")
\end{lstlisting}

\subsection{Audio Playback Thread}

A separate thread handles audio playback:

\begin{lstlisting}[language=Python, caption=Audio Playback Thread, label=lst:audio-playback]
def play_audio(self):
    """Playback audio from jitter buffer"""
    while self.audio_playing:
        try:
            # Wait for buffer to have some data
            if self.audio_buffer.qsize() < 5:
                time.sleep(0.01)
                continue
            
            # Get audio chunk from buffer
            audio_data = self.audio_buffer.get(timeout=0.1)
            
            # Play through speakers
            self.audio_output_stream.write(audio_data)
            
        except queue.Empty:
            # Buffer empty - play silence
            silence = b'\x00' * (CHUNK * 2)
            self.audio_output_stream.write(silence)
        except Exception as e:
            print(f"Audio playback error: {e}")
\end{lstlisting}

\subsection{Jitter Buffer Benefits}

\begin{table}[H]
\centering
\caption{Jitter Buffer Performance}
\label{tab:jitter-buffer}
\begin{tabular}{lll}
\toprule
\textbf{Metric} & \textbf{Without Buffer} & \textbf{With Buffer (20 chunks)} \\
\midrule
Latency & 23 ms & 460 ms \\
Packet Loss Tolerance & Poor & Good \\
Audio Quality & Choppy & Smooth \\
Network Jitter Tolerance & Low & High \\
\bottomrule
\end{tabular}
\end{table}

The trade-off: Higher latency for smoother, more reliable audio.

\section{Audio Controls}

\subsection{Mute/Unmute Functionality}

\begin{lstlisting}[language=Python, caption=Audio Toggle Control, label=lst:audio-toggle]
def toggle_audio(self):
    """Toggle microphone on/off"""
    if not self.audio_capturing:
        # Start audio
        self.audio_capturing = True
        self.audio_playing = True
        
        # Notify server
        self.tcp_socket.send(b"AUDIO_START")
        
        # Start threads
        threading.Thread(target=self.capture_audio, 
                        daemon=True).start()
        threading.Thread(target=self.receive_audio, 
                        daemon=True).start()
        threading.Thread(target=self.play_audio, 
                        daemon=True).start()
        
        # Update UI
        self.audio_button.setText("Mute")
        self.audio_button.setStyleSheet("background: #dc3545")
        
    else:
        # Stop audio
        self.audio_capturing = False
        self.audio_playing = False
        
        # Notify server
        self.tcp_socket.send(b"AUDIO_STOP")
        
        # Update UI
        self.audio_button.setText("Unmute")
        self.audio_button.setStyleSheet("background: #28a745")
\end{lstlisting}

\section{Performance Characteristics}

\subsection{Latency Analysis}

\begin{table}[H]
\centering
\caption{Audio Latency Breakdown}
\label{tab:audio-latency}
\begin{tabular}{lr}
\toprule
\textbf{Component} & \textbf{Latency} \\
\midrule
Capture buffer (1024 samples @ 44.1kHz) & 23 ms \\
Network transmission (LAN) & 1-5 ms \\
Server processing (mixing) & $<$1 ms \\
Network return (LAN) & 1-5 ms \\
Jitter buffer (5 chunks minimum) & 115 ms \\
Playback buffer & 23 ms \\
\midrule
\textbf{Total End-to-End Latency} & \textbf{163-168 ms} \\
\bottomrule
\end{tabular}
\end{table}

This latency is acceptable for LAN-based conferencing but would be noticeable over WAN.

\subsection{Bandwidth Usage}

\begin{table}[H]
\centering
\caption{Audio Bandwidth Calculation}
\label{tab:audio-bandwidth}
\begin{tabular}{lr}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Sample Rate & 44,100 Hz \\
Bit Depth & 16 bits \\
Channels & 1 (Mono) \\
\midrule
Bits per second & 705,600 bps \\
Bytes per second & 88,200 bytes/s \\
\midrule
\textbf{Bandwidth per client} & \textbf{705.6 Kbps} \\
\textbf{Bandwidth for 10 users (uplink)} & \textbf{7.056 Mbps} \\
\textbf{Bandwidth for mixed audio (downlink)} & \textbf{705.6 Kbps} \\
\bottomrule
\end{tabular}
\end{table}

Server uplink bandwidth scales linearly with user count, but each client's downlink is constant.

% ============================================================================
% CHAPTER 6: SCREEN SHARING MODULE
% ============================================================================
\chapter{Screen Sharing Module}

\section{Overview}

The screen sharing module allows one user at a time to share their screen with all other participants. The system uses a presenter model where users request to become the presenter, and only one presenter can be active at any given time.

\section{Presenter Role Management}

\subsection{Request Protocol}

Users request the presenter role through TCP control connection:

\begin{lstlisting}[language=Python, caption=Presenter Request, label=lst:presenter-request]
def request_presenter_role(self):
    """Request to become screen share presenter"""
    try:
        # Connect to screen control port
        self.screen_control_socket = socket.socket(
            socket.AF_INET, 
            socket.SOCK_STREAM
        )
        self.screen_control_socket.connect(
            (self.server_address, SCREEN_CONTROL_PORT)
        )
        
        # Send presenter request
        message = f"REQUEST_PRESENTER:{self.client_id}"
        self.screen_control_socket.send(message.encode())
        
        # Wait for response
        response = self.screen_control_socket.recv(1024).decode()
        
        if response == "PRESENTER_GRANTED":
            self.is_presenting = True
            self.start_screen_capture()
            
            # Update UI
            self.screen_button.setText("Stop Sharing")
            self.screen_button.setStyleSheet("background: #dc3545")
            
        elif response == "PRESENTER_DENIED":
            QMessageBox.information(
                self,
                "Screen Share",
                "Someone else is currently presenting.\n"
                "Please try again later."
            )
            
    except Exception as e:
        print(f"Presenter request error: {e}")
\end{lstlisting}

\subsection{Server-Side Presenter Management}

The server ensures only one presenter at a time:

\begin{lstlisting}[language=Python, caption=Server Presenter Management, label=lst:server-presenter]
def handle_screen_control(self, conn, addr):
    """Handle screen sharing control connection"""
    try:
        data = conn.recv(1024).decode()
        
        if data.startswith("REQUEST_PRESENTER"):
            _, client_id = data.split(':')
            client_id = int(client_id)
            
            with self.presenter_lock:
                if self.presenter_id is None:
                    # Grant presenter role
                    self.presenter_id = client_id
                    conn.send(b"PRESENTER_GRANTED")
                    
                    # Notify all clients
                    username = self.clients[client_id]['username']
                    self.broadcast_message(
                        f"PRESENTER_STARTED:{client_id}:{username}"
                    )
                    
                else:
                    # Deny - already presenting
                    conn.send(b"PRESENTER_DENIED")
        
        elif data == "STOP_PRESENTING":
            with self.presenter_lock:
                if self.presenter_id is not None:
                    self.presenter_id = None
                    
                    # Notify all clients
                    self.broadcast_message("PRESENTER_STOPPED")
                    
    except Exception as e:
        print(f"Screen control error: {e}")
    finally:
        conn.close()
\end{lstlisting}

\section{Screen Capture}

\subsection{MSS Library}

The module uses the MSS (Multiple Screen Shots) library for fast screen capture:

\begin{lstlisting}[language=Python, caption=Screen Capture with MSS, label=lst:screen-capture]
import mss
import mss.tools

def capture_screen(self):
    """Capture and transmit screen frames"""
    with mss.mss() as sct:
        # Get primary monitor
        monitor = sct.monitors[1]
        
        while self.is_presenting:
            start_time = time.time()
            
            # Capture screenshot
            screenshot = sct.grab(monitor)
            
            # Convert to NumPy array
            frame = np.array(screenshot)
            
            # Convert BGRA to BGR
            frame = cv2.cvtColor(frame, cv2.COLOR_BGRA2BGR)
            
            # Resize to reduce bandwidth (960x540)
            frame = cv2.resize(frame, (960, 540))
            
            # Compress as JPEG (quality 50)
            _, buffer = cv2.imencode('.jpg', frame,
                [cv2.IMWRITE_JPEG_QUALITY, 50])
            
            # Send frame
            self.send_screen_frame(buffer.tobytes())
            
            # Target 10 FPS
            elapsed = time.time() - start_time
            sleep_time = max(0, 0.1 - elapsed)
            time.sleep(sleep_time)
\end{lstlisting}

\subsection{Screen Capture Performance}

\begin{table}[H]
\centering
\caption{Screen Capture Library Comparison}
\label{tab:screen-capture-libs}
\begin{tabular}{lrr}
\toprule
\textbf{Library} & \textbf{FPS (1920x1080)} & \textbf{CPU Usage} \\
\midrule
PIL ImageGrab & 5-8 & High \\
PyAutoGUI & 3-5 & High \\
\textbf{MSS (Selected)} & \textbf{30-60} & \textbf{Low} \\
python-mss & 30-60 & Low \\
\bottomrule
\end{tabular}
\end{table}

MSS was selected for its superior performance and cross-platform support.

\section{Screen Frame Transmission}

\subsection{Frame Encoding and Sending}

Screen frames use the same format as video frames:

\begin{lstlisting}[language=Python, caption=Screen Frame Transmission, label=lst:screen-send]
def send_screen_frame(self, frame_data):
    """Send screen frame via UDP"""
    try:
        frame_length = len(frame_data)
        
        # Create packet
        packet = struct.pack('>I', self.client_id)
        packet += struct.pack('>I', frame_length)
        packet += frame_data
        
        # Send via UDP
        self.screen_data_socket.sendto(
            packet,
            (self.server_address, SCREEN_DATA_PORT)
        )
        
    except Exception as e:
        print(f"Screen frame send error: {e}")
\end{lstlisting}

\subsection{Server Broadcasting}

The server validates the presenter and broadcasts frames:

\begin{lstlisting}[language=Python, caption=Server Screen Frame Broadcasting, label=lst:server-screen-broadcast]
def receive_screen_frames(self):
    """Receive and broadcast screen frames"""
    while self.running:
        try:
            data, addr = self.screen_socket.recvfrom(65536)
            
            if len(data) < 8:
                continue
            
            # Parse packet
            sender_id = struct.unpack('>I', data[0:4])[0]
            
            # Verify sender is current presenter
            with self.presenter_lock:
                if sender_id != self.presenter_id:
                    continue  # Ignore unauthorized frames
            
            # Broadcast to all clients
            with self.clients_lock:
                for client_id, client_info in self.clients.items():
                    if 'screen_udp_address' not in client_info:
                        continue
                    
                    try:
                        self.screen_socket.sendto(
                            data,
                            client_info['screen_udp_address']
                        )
                    except Exception as e:
                        print(f"Screen broadcast error: {e}")
                        
        except Exception as e:
            print(f"Screen reception error: {e}")
\end{lstlisting}

\section{Screen Display}

\subsection{Full-Screen Display Mode}

When a presenter is active, viewers can see the shared screen:

\begin{lstlisting}[language=Python, caption=Screen Display Implementation, label=lst:screen-display]
def receive_screen_frames(self):
    """Receive and display presenter's screen"""
    while True:
        try:
            data, _ = self.screen_data_socket.recvfrom(65536)
            
            if len(data) < 8:
                continue
            
            # Parse frame
            presenter_id = struct.unpack('>I', data[0:4])[0]
            frame_length = struct.unpack('>I', data[4:8])[0]
            frame_data = data[8:8+frame_length]
            
            # Decode JPEG
            frame_array = np.frombuffer(frame_data, 
                                       dtype=np.uint8)
            frame = cv2.imdecode(frame_array, cv2.IMREAD_COLOR)
            
            if frame is None:
                continue
            
            # Update screen display
            self.update_screen_display.emit(frame)
            
        except Exception as e:
            print(f"Screen reception error: {e}")

def update_screen_display(self, frame):
    """Update screen share display widget"""
    # Convert to QPixmap
    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    h, w, ch = rgb_frame.shape
    bytes_per_line = ch * w
    qt_image = QImage(rgb_frame.data, w, h,
                     bytes_per_line, QImage.Format_RGB888)
    pixmap = QPixmap.fromImage(qt_image)
    
    # Display in screen share label
    self.screen_display_label.setPixmap(
        pixmap.scaled(self.screen_display_label.size(),
                     Qt.KeepAspectRatio,
                     Qt.SmoothTransformation)
    )
    
    # Show screen share panel
    self.screen_panel.setVisible(True)
\end{lstlisting}

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.9\textwidth}{\centering
        \vspace{2cm}
        \textbf{[SCREENSHOT PLACEHOLDER]}\\
        \vspace{0.5cm}
        Screen Sharing Display\\
        Showing presenter's screen in viewer mode\\
        \vspace{2cm}
    }}
    \caption{Screen Sharing Interface}
    \label{fig:screen-share}
\end{figure}

\section{Stopping Screen Share}

\subsection{Graceful Release}

Presenter can stop sharing:

\begin{lstlisting}[language=Python, caption=Stop Screen Sharing, label=lst:stop-screen]
def stop_screen_share(self):
    """Stop sharing screen"""
    self.is_presenting = False
    
    # Notify server
    try:
        self.screen_control_socket.send(b"STOP_PRESENTING")
        self.screen_control_socket.close()
    except:
        pass
    
    # Update UI
    self.screen_button.setText("Share Screen")
    self.screen_button.setStyleSheet("background: #007bff")
    
    # Hide screen panel for all viewers
    self.screen_panel.setVisible(False)
\end{lstlisting}

\section{Performance Optimization}

\subsection{Resolution and Quality Trade-offs}

\begin{table}[H]
\centering
\caption{Screen Sharing Configuration Options}
\label{tab:screen-configs}
\begin{tabular}{lrrrr}
\toprule
\textbf{Config} & \textbf{Resolution} & \textbf{FPS} & \textbf{Quality} & \textbf{Bandwidth} \\
\midrule
High & 1920 × 1080 & 15 & 70 & 12-18 Mbps \\
Medium & 1280 × 720 & 15 & 60 & 6-10 Mbps \\
\textbf{Default} & \textbf{960 × 540} & \textbf{10} & \textbf{50} & \textbf{2.4-4 Mbps} \\
Low & 640 × 360 & 10 & 40 & 1-2 Mbps \\
\bottomrule
\end{tabular}
\end{table}

The default configuration balances readability with bandwidth efficiency.

\subsection{Frame Rate Selection}

10 FPS was chosen for screen sharing because:
\begin{itemize}[itemsep=5pt]
    \item Screen content changes less frequently than camera video
    \item Lower bandwidth requirements
    \item Still provides smooth experience for presentations
    \item Sufficient for document/slide viewing
\end{itemize}

Higher frame rates (15-30 FPS) may be beneficial for:
\begin{itemize}[itemsep=5pt]
    \item Video playback
    \item Gaming demonstrations
    \item Animations
\end{itemize}

% End of Chapter 6

% ============================================================================
% CHAPTER 7: CHAT MODULE
% ============================================================================
\chapter{Chat Module}

\section{Overview}

The chat module provides text-based communication between users through both group messaging (visible to all) and private messaging (one-to-one). All chat messages are transmitted over the reliable TCP control connection and stored server-side for chat history.

\section{Chat Architecture}

\subsection{Message Types}

The system supports two types of chat messages:

\begin{enumerate}[itemsep=5pt]
    \item \textbf{Group Messages}: Broadcast to all connected users
    \item \textbf{Private Messages}: Sent only to specific recipient
\end{enumerate}

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.9\textwidth}{\centering
        \vspace{2cm}
        \textbf{[SCREENSHOT PLACEHOLDER]}\\
        \vspace{0.5cm}
        Chat Interface\\
        Showing group and private messages with user list\\
        \vspace{2cm}
    }}
    \caption{Chat Module Interface}
    \label{fig:chat-interface}
\end{figure}

\section{Sending Messages}

\subsection{Group Chat Implementation}

\begin{lstlisting}[language=Python, caption=Sending Group Messages, label=lst:send-group-chat]
def send_group_message(self):
    """Send message to all users"""
    message = self.chat_input.text().strip()
    
    if not message:
        return
    
    try:
        # Send to server
        msg = f"CHAT:{message}"
        self.tcp_socket.send(msg.encode())
        
        # Clear input field
        self.chat_input.clear()
        
    except Exception as e:
        print(f"Error sending message: {e}")
        QMessageBox.warning(self, "Error", 
            "Failed to send message")
\end{lstlisting}

\subsection{Private Chat Implementation}

\begin{lstlisting}[language=Python, caption=Sending Private Messages, label=lst:send-private-chat]
def send_private_message(self, recipient_id):
    """Send private message to specific user"""
    message = self.chat_input.text().strip()
    
    if not message:
        return
    
    try:
        # Send to server with recipient ID
        msg = f"PRIVATE:{recipient_id}:{message}"
        self.tcp_socket.send(msg.encode())
        
        # Display in chat (shown with lock icon)
        timestamp = datetime.now().strftime("%H:%M:%S")
        recipient_name = self.users[recipient_id]['username']
        
        self.add_chat_message(
            f"You (to {recipient_name})",
            message,
            timestamp,
            is_private=True,
            is_own=True
        )
        
        self.chat_input.clear()
        
    except Exception as e:
        print(f"Error sending private message: {e}")
\end{lstlisting}

\subsection{Chat Input Widget}

\begin{lstlisting}[language=Python, caption=Chat Input UI, label=lst:chat-input-ui]
def setup_chat_input(self):
    """Create chat input area"""
    input_layout = QHBoxLayout()
    
    # Text input
    self.chat_input = QLineEdit()
    self.chat_input.setPlaceholderText(
        "Type a message..."
    )
    self.chat_input.setStyleSheet("""
        QLineEdit {
            padding: 10px;
            border: 2px solid #444;
            border-radius: 20px;
            background: #2a2a2a;
            color: white;
            font-size: 14px;
        }
    """)
    
    # Send on Enter key
    self.chat_input.returnPressed.connect(
        self.send_group_message
    )
    
    # Send button
    send_btn = QPushButton("Send")
    send_btn.setStyleSheet("""
        QPushButton {
            background: #007bff;
            color: white;
            border-radius: 20px;
            padding: 10px 20px;
            font-weight: bold;
        }
        QPushButton:hover {
            background: #0056b3;
        }
    """)
    send_btn.clicked.connect(self.send_group_message)
    
    input_layout.addWidget(self.chat_input)
    input_layout.addWidget(send_btn)
\end{lstlisting}

\section{Server-Side Message Handling}

\subsection{Group Message Broadcasting}

\begin{lstlisting}[language=Python, caption=Server Group Message Handling, label=lst:server-group-chat]
def handle_chat_message(self, client_id, message):
    """Handle group chat message from client"""
    try:
        # Get sender info
        username = self.clients[client_id]['username']
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        # Store in chat history
        chat_entry = {
            'type': 'group',
            'sender_id': client_id,
            'username': username,
            'message': message,
            'timestamp': timestamp
        }
        
        with self.chat_lock:
            self.chat_history.append(chat_entry)
        
        # Broadcast to all clients
        broadcast_msg = f"CHAT:{client_id}:{username}:{message}:{timestamp}"
        self.broadcast_message(broadcast_msg)
        
        print(f"[CHAT] {username}: {message}")
        
    except Exception as e:
        print(f"Error handling chat message: {e}")
\end{lstlisting}

\subsection{Private Message Routing}

\begin{lstlisting}[language=Python, caption=Server Private Message Handling, label=lst:server-private-chat]
def handle_private_message(self, sender_id, recipient_id, message):
    """Route private message to specific recipient"""
    try:
        # Get sender info
        sender_name = self.clients[sender_id]['username']
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        # Validate recipient exists
        if recipient_id not in self.clients:
            # Send error to sender
            error_msg = "ERROR:Recipient not found"
            self.clients[sender_id]['tcp_conn'].send(
                error_msg.encode()
            )
            return
        
        # Store in chat history
        chat_entry = {
            'type': 'private',
            'sender_id': sender_id,
            'recipient_id': recipient_id,
            'username': sender_name,
            'message': message,
            'timestamp': timestamp
        }
        
        with self.chat_lock:
            self.chat_history.append(chat_entry)
        
        # Send to recipient
        private_msg = f"PRIVATE:{sender_id}:{sender_name}:{message}:{timestamp}"
        self.clients[recipient_id]['tcp_conn'].send(
            private_msg.encode()
        )
        
        print(f"[PRIVATE] {sender_name} -> {recipient_id}: {message}")
        
    except Exception as e:
        print(f"Error handling private message: {e}")
\end{lstlisting}

\section{Receiving and Displaying Messages}

\subsection{Message Reception}

\begin{lstlisting}[language=Python, caption=Client Message Reception, label=lst:receive-chat]
def handle_server_message(self, message):
    """Process incoming message from server"""
    try:
        parts = message.split(':', 3)
        msg_type = parts[0]
        
        if msg_type == "CHAT":
            # Group message: CHAT:sender_id:username:message:timestamp
            sender_id = int(parts[1])
            username = parts[2]
            msg_content = parts[3]
            timestamp = parts[4] if len(parts) > 4 else ""
            
            # Don't display own messages (already shown)
            if sender_id != self.client_id:
                self.add_chat_message(
                    username,
                    msg_content,
                    timestamp,
                    is_private=False
                )
        
        elif msg_type == "PRIVATE":
            # Private message: PRIVATE:sender_id:username:message:timestamp
            sender_id = int(parts[1])
            sender_name = parts[2]
            msg_content = parts[3]
            timestamp = parts[4] if len(parts) > 4 else ""
            
            self.add_chat_message(
                f"{sender_name} (private)",
                msg_content,
                timestamp,
                is_private=True
            )
            
            # Show notification
            self.show_notification(
                f"Private message from {sender_name}",
                msg_content
            )
    
    except Exception as e:
        print(f"Error handling message: {e}")
\end{lstlisting}

\subsection{Chat Message Display}

\begin{lstlisting}[language=Python, caption=Chat Message Display, label=lst:display-chat]
def add_chat_message(self, sender, message, timestamp, 
                     is_private=False, is_own=False):
    """Add message to chat display"""
    
    # Create message widget
    msg_widget = QWidget()
    msg_layout = QVBoxLayout(msg_widget)
    msg_layout.setContentsMargins(10, 5, 10, 5)
    
    # Header (sender + timestamp)
    header_layout = QHBoxLayout()
    
    sender_label = QLabel(sender)
    sender_label.setStyleSheet("""
        font-weight: bold;
        color: #64b5f6;
        font-size: 13px;
    """)
    
    time_label = QLabel(timestamp)
    time_label.setStyleSheet("""
        color: #999;
        font-size: 11px;
    """)
    
    header_layout.addWidget(sender_label)
    
    # Private message indicator
    if is_private:
        lock_icon = QLabel("[LOCK]")
        lock_icon.setStyleSheet("font-size: 11px;")
        header_layout.addWidget(lock_icon)
    
    header_layout.addStretch()
    header_layout.addWidget(time_label)
    
    # Message content
    message_label = QLabel(message)
    message_label.setWordWrap(True)
    message_label.setStyleSheet("""
        color: white;
        padding: 8px;
        background: #333;
        border-radius: 8px;
        font-size: 13px;
    """)
    
    # Own messages have different color
    if is_own:
        message_label.setStyleSheet("""
            color: white;
            padding: 8px;
            background: #007bff;
            border-radius: 8px;
            font-size: 13px;
        """)
    
    msg_layout.addLayout(header_layout)
    msg_layout.addWidget(message_label)
    
    # Add to chat area
    self.chat_layout.addWidget(msg_widget)
    
    # Auto-scroll to bottom
    QTimer.singleShot(100, self.scroll_chat_to_bottom)
\end{lstlisting}

\section{Chat History}

\subsection{Loading Chat History}

When a user joins, they receive recent chat history:

\begin{lstlisting}[language=Python, caption=Sending Chat History, label=lst:send-history]
def send_chat_history(self, client_id):
    """Send recent chat history to newly joined client"""
    try:
        with self.chat_lock:
            # Get last 50 messages
            recent_messages = self.chat_history[-50:]
        
        if not recent_messages:
            return
        
        # Format history message
        history_parts = []
        for msg in recent_messages:
            # Format: type:sender_id:username:message:timestamp
            if msg['type'] == 'group':
                history_parts.append(
                    f"group:{msg['sender_id']}:{msg['username']}:"
                    f"{msg['message']}:{msg['timestamp']}"
                )
            # Don't send private messages in history
        
        if history_parts:
            history_msg = "CHAT_HISTORY:" + "|".join(history_parts)
            self.clients[client_id]['tcp_conn'].send(
                history_msg.encode()
            )
    
    except Exception as e:
        print(f"Error sending chat history: {e}")
\end{lstlisting}

\subsection{Displaying Chat History}

\begin{lstlisting}[language=Python, caption=Loading Chat History on Client, label=lst:load-history]
def load_chat_history(self, history_data):
    """Load and display chat history"""
    try:
        messages = history_data.split('|')
        
        for msg in messages:
            parts = msg.split(':', 4)
            
            if len(parts) < 5:
                continue
            
            msg_type, sender_id, username, content, timestamp = parts
            
            self.add_chat_message(
                username,
                content,
                timestamp,
                is_private=(msg_type == 'private')
            )
        
        # Add separator
        separator = QLabel("-" * 50)
        separator.setStyleSheet("color: #666;")
        self.chat_layout.addWidget(separator)
        
    except Exception as e:
        print(f"Error loading chat history: {e}")
\end{lstlisting}

\section{User List and Private Chat Selection}

\subsection{User List Display}

\begin{lstlisting}[language=Python, caption=User List Widget, label=lst:user-list]
def update_user_list(self, users):
    """Update the list of online users"""
    # Clear existing list
    self.user_list_widget.clear()
    
    for user_id, user_info in users.items():
        # Skip self
        if user_id == self.client_id:
            continue
        
        # Create user item
        item = QListWidgetItem()
        
        # User widget with name and status
        user_widget = QWidget()
        layout = QHBoxLayout(user_widget)
        
        # Online indicator
        status_dot = QLabel("O")
        status_dot.setStyleSheet("color: #28a745; font-size: 16px;")
        
        # Username
        name_label = QLabel(user_info['username'])
        name_label.setStyleSheet("color: white; font-size: 14px;")
        
        # Private message button
        pm_btn = QPushButton("PM")
        pm_btn.setFixedSize(30, 30)
        pm_btn.setStyleSheet("""
            QPushButton {
                background: #007bff;
                border-radius: 15px;
                font-size: 14px;
            }
            QPushButton:hover {
                background: #0056b3;
            }
        """)
        pm_btn.clicked.connect(
            lambda checked, uid=user_id: self.open_private_chat(uid)
        )
        
        layout.addWidget(status_dot)
        layout.addWidget(name_label)
        layout.addStretch()
        layout.addWidget(pm_btn)
        
        item.setSizeHint(user_widget.sizeHint())
        self.user_list_widget.addItem(item)
        self.user_list_widget.setItemWidget(item, user_widget)
\end{lstlisting}

\subsection{Private Chat Dialog}

\begin{lstlisting}[language=Python, caption=Private Chat Selection, label=lst:private-chat-dialog]
def open_private_chat(self, recipient_id):
    """Open private chat with specific user"""
    recipient_name = self.users[recipient_id]['username']
    
    # Show dialog
    message, ok = QInputDialog.getText(
        self,
        f"Private Message to {recipient_name}",
        "Enter message:",
        QLineEdit.Normal
    )
    
    if ok and message:
        self.send_private_message(recipient_id, message)
\end{lstlisting}

\section{Notifications}

\subsection{Desktop Notifications}

\begin{lstlisting}[language=Python, caption=Chat Notifications, label=lst:chat-notifications]
def show_notification(self, title, message):
    """Show desktop notification for new message"""
    try:
        # Create notification widget
        notification = QMessageBox(self)
        notification.setWindowTitle(title)
        notification.setText(message)
        notification.setIcon(QMessageBox.Information)
        notification.setStandardButtons(QMessageBox.Ok)
        
        # Auto-close after 3 seconds
        QTimer.singleShot(3000, notification.close)
        
        # Show notification
        notification.show()
        
        # Play sound (optional)
        # self.play_notification_sound()
        
    except Exception as e:
        print(f"Notification error: {e}")
\end{lstlisting}

\subsection{Notification Types}

The application displays notifications for various events:

\begin{itemize}[itemsep=5pt]
    \item \textbf{Chat Messages}: New message received (group or private)
    \item \textbf{User Joined}: New participant connected
    \item \textbf{User Left}: Participant disconnected
    \item \textbf{File Uploaded}: New file available for download
    \item \textbf{Screen Share}: Presenter started/stopped sharing
    \item \textbf{Connection Events}: Connected, disconnected, errors
\end{itemize}

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.6\textwidth}{\centering
        \vspace{1.5cm}
        \textbf{[SCREENSHOT PLACEHOLDER]}\\
        \vspace{0.5cm}
        Chat Message Notification\\
        Toast notification for new message\\
        \vspace{1.5cm}
    }}
    \caption{Chat Message Notification Popup}
    \label{fig:chat-notification}
\end{figure}

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.6\textwidth}{\centering
        \vspace{1.5cm}
        \textbf{[SCREENSHOT PLACEHOLDER]}\\
        \vspace{0.5cm}
        User Join/Leave Notification\\
        Participant connection status update\\
        \vspace{1.5cm}
    }}
    \caption{User Join/Leave Notification Popup}
    \label{fig:user-notification}
\end{figure}

\section{Chat Features Summary}

\begin{table}[H]
\centering
\caption{Chat Module Features}
\label{tab:chat-features}
\begin{tabular}{ll}
\toprule
\textbf{Feature} & \textbf{Description} \\
\midrule
Group Chat & Messages broadcast to all connected users \\
Private Chat & One-to-one messaging between users \\
Chat History & Last 50 messages sent to joining users \\
User List & Real-time list of online users \\
Timestamps & All messages include time sent \\
Visual Indicators & Private messages marked with lock icon \\
Notifications & Desktop notifications for new messages \\
Auto-scroll & Chat automatically scrolls to newest messages \\
Message Styling & Different colors for own/other/private messages \\
Persistence & Server stores all messages during session \\
\bottomrule
\end{tabular}
\end{table}

% ============================================================================
% CHAPTER 8: FILE SHARING MODULE
% ============================================================================
\chapter{File Sharing Module}

\section{Overview}

The file sharing module allows users to upload files to the server and download files shared by others. Files are stored in server memory for the duration of the session and are available to all connected users.

\section{File Upload}

\subsection{File Selection}

\begin{lstlisting}[language=Python, caption=File Selection Dialog, label=lst:file-selection]
def select_and_upload_file(self):
    """Open file dialog and upload selected file"""
    try:
        # Open file dialog
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select File to Upload",
            "",
            "All Files (*.*)"
        )
        
        if not file_path:
            return
        
        # Check file size
        file_size = os.path.getsize(file_path)
        
        if file_size > MAX_FILE_SIZE:  # 100 MB
            QMessageBox.warning(
                self,
                "File Too Large",
                f"File size ({file_size / 1024 / 1024:.1f} MB) "
                f"exceeds maximum ({MAX_FILE_SIZE / 1024 / 1024} MB)"
            )
            return
        
        # Start upload in separate thread
        upload_thread = threading.Thread(
            target=self.upload_file,
            args=(file_path,),
            daemon=True
        )
        upload_thread.start()
        
    except Exception as e:
        print(f"File selection error: {e}")
        QMessageBox.warning(self, "Error", 
            f"Failed to select file: {e}")
\end{lstlisting}

\subsection{File Upload Implementation}

\begin{lstlisting}[language=Python, caption=File Upload with Progress, label=lst:file-upload-impl]
def upload_file(self, file_path):
    """Upload file to server with progress tracking"""
    try:
        # Connect to file transfer port
        file_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        file_socket.connect((self.server_address, FILE_TRANSFER_PORT))
        
        # Get file info
        filename = os.path.basename(file_path)
        file_size = os.path.getsize(file_path)
        
        # Send upload request
        request = f"UPLOAD:{filename}:{file_size}"
        file_socket.send(request.encode())
        
        # Wait for server response
        response = file_socket.recv(1024).decode()
        
        if not response.startswith("UPLOAD_READY"):
            raise Exception("Server rejected upload")
        
        # Get file ID
        file_id = int(response.split(':')[1])
        
        # Show progress dialog
        self.show_upload_progress.emit(filename, file_size)
        
        # Send file in chunks
        CHUNK_SIZE = 8192  # 8 KB
        total_sent = 0
        
        with open(file_path, 'rb') as f:
            while total_sent < file_size:
                chunk = f.read(CHUNK_SIZE)
                if not chunk:
                    break
                
                file_socket.send(chunk)
                total_sent += len(chunk)
                
                # Update progress
                progress = int((total_sent / file_size) * 100)
                self.update_upload_progress.emit(progress)
                
                # Wait for acknowledgment
                ack = file_socket.recv(1024)
        
        # Wait for completion confirmation
        completion = file_socket.recv(1024).decode()
        
        if completion == "UPLOAD_COMPLETE":
            self.upload_complete.emit(filename)
            QMessageBox.information(
                self,
                "Upload Complete",
                f"File '{filename}' uploaded successfully!"
            )
        
        file_socket.close()
        
    except Exception as e:
        print(f"Upload error: {e}")
        self.upload_error.emit(str(e))
\end{lstlisting}

\subsection{Upload Progress Dialog}

\begin{lstlisting}[language=Python, caption=Upload Progress Dialog, label=lst:upload-progress]
def show_upload_progress_dialog(self, filename, total_size):
    """Display upload progress dialog"""
    self.upload_dialog = QProgressDialog(
        f"Uploading {filename}...",
        "Cancel",
        0,
        100,
        self
    )
    self.upload_dialog.setWindowTitle("File Upload")
    self.upload_dialog.setWindowModality(Qt.WindowModal)
    self.upload_dialog.setValue(0)
    self.upload_dialog.show()
    
def update_upload_progress_value(self, progress):
    """Update upload progress bar"""
    if hasattr(self, 'upload_dialog'):
        self.upload_dialog.setValue(progress)
        
def upload_complete_handler(self, filename):
    """Handle upload completion"""
    if hasattr(self, 'upload_dialog'):
        self.upload_dialog.close()
\end{lstlisting}

\section{Server-Side File Management}

\subsection{File Upload Handler}

\begin{lstlisting}[language=Python, caption=Server File Upload Handler, label=lst:server-upload]
def handle_file_upload(self, conn, addr):
    """Handle file upload from client"""
    try:
        # Receive upload request
        request = conn.recv(1024).decode()
        
        if not request.startswith("UPLOAD"):
            return
        
        # Parse request: UPLOAD:filename:filesize
        _, filename, filesize = request.split(':')
        filesize = int(filesize)
        
        # Validate file size
        if filesize > MAX_FILE_SIZE:
            conn.send(b"ERROR:File too large")
            return
        
        # Generate file ID
        file_id = self.next_file_id
        self.next_file_id += 1
        
        # Send ready response
        conn.send(f"UPLOAD_READY:{file_id}".encode())
        
        # Receive file in chunks
        file_data = bytearray()
        CHUNK_SIZE = 8192
        received = 0
        
        while received < filesize:
            chunk = conn.recv(min(CHUNK_SIZE, filesize - received))
            if not chunk:
                break
            
            file_data.extend(chunk)
            received += len(chunk)
            
            # Acknowledge chunk
            conn.send(b"CHUNK_ACK")
        
        # Get uploader info
        uploader_id = self.get_client_id_by_socket(conn)
        uploader_name = self.clients[uploader_id]['username']
        
        # Store file
        with self.files_lock:
            self.shared_files[file_id] = {
                'filename': filename,
                'size': filesize,
                'uploader_id': uploader_id,
                'uploader_name': uploader_name,
                'data': bytes(file_data),
                'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            }
        
        # Send completion
        conn.send(b"UPLOAD_COMPLETE")
        
        # Broadcast file availability
        file_msg = (
            f"FILE_AVAILABLE:{file_id}:{filename}:"
            f"{filesize}:{uploader_name}"
        )
        self.broadcast_message(file_msg)
        
        print(f"File uploaded: {filename} ({filesize} bytes) "
              f"by {uploader_name}")
        
    except Exception as e:
        print(f"Upload handling error: {e}")
    finally:
        conn.close()
\end{lstlisting}

\subsection{File Download Handler}

\begin{lstlisting}[language=Python, caption=Server File Download Handler, label=lst:server-download]
def handle_file_download(self, conn, addr):
    """Handle file download request"""
    try:
        # Receive download request
        request = conn.recv(1024).decode()
        
        if not request.startswith("DOWNLOAD"):
            return
        
        # Parse request: DOWNLOAD:file_id
        _, file_id = request.split(':')
        file_id = int(file_id)
        
        # Check if file exists
        with self.files_lock:
            if file_id not in self.shared_files:
                conn.send(b"ERROR:File not found")
                return
            
            file_info = self.shared_files[file_id]
        
        # Send file metadata
        metadata = (
            f"DOWNLOAD_START:{file_info['filename']}:"
            f"{file_info['size']}"
        )
        conn.send(metadata.encode())
        
        # Send file in chunks
        CHUNK_SIZE = 8192
        file_data = file_info['data']
        total_sent = 0
        
        while total_sent < len(file_data):
            chunk = file_data[total_sent:total_sent + CHUNK_SIZE]
            conn.send(chunk)
            total_sent += len(chunk)
            
            # Wait for acknowledgment
            ack = conn.recv(1024)
        
        # Send completion
        conn.send(b"DOWNLOAD_COMPLETE")
        
        print(f"File downloaded: {file_info['filename']}")
        
    except Exception as e:
        print(f"Download handling error: {e}")
    finally:
        conn.close()
\end{lstlisting}

\section{Client-Side File Download}

\subsection{File Download Implementation}

\begin{lstlisting}[language=Python, caption=Client File Download, label=lst:client-download]
def download_file(self, file_id, filename, filesize):
    """Download file from server"""
    try:
        # Ask where to save
        save_path, _ = QFileDialog.getSaveFileName(
            self,
            "Save File As",
            filename,
            "All Files (*.*)"
        )
        
        if not save_path:
            return
        
        # Connect to file transfer port
        file_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        file_socket.connect((self.server_address, FILE_TRANSFER_PORT))
        
        # Send download request
        request = f"DOWNLOAD:{file_id}"
        file_socket.send(request.encode())
        
        # Receive metadata
        response = file_socket.recv(1024).decode()
        
        if response.startswith("ERROR"):
            raise Exception(response.split(':')[1])
        
        # Show progress
        self.show_download_progress.emit(filename, filesize)
        
        # Receive file in chunks
        CHUNK_SIZE = 8192
        total_received = 0
        
        with open(save_path, 'wb') as f:
            while total_received < filesize:
                chunk = file_socket.recv(
                    min(CHUNK_SIZE, filesize - total_received)
                )
                if not chunk:
                    break
                
                f.write(chunk)
                total_received += len(chunk)
                
                # Update progress
                progress = int((total_received / filesize) * 100)
                self.update_download_progress.emit(progress)
                
                # Acknowledge chunk
                file_socket.send(b"CHUNK_ACK")
        
        # Receive completion
        completion = file_socket.recv(1024).decode()
        
        if completion == "DOWNLOAD_COMPLETE":
            self.download_complete.emit(filename)
            QMessageBox.information(
                self,
                "Download Complete",
                f"File saved to:\n{save_path}"
            )
        
        file_socket.close()
        
    except Exception as e:
        print(f"Download error: {e}")
        self.download_error.emit(str(e))
\end{lstlisting}

\section{File List Display}

\subsection{File List Widget}

\begin{lstlisting}[language=Python, caption=File List Display, label=lst:file-list]
def update_file_list(self, files):
    """Update shared files list"""
    self.file_list_widget.clear()
    
    for file_id, file_info in files.items():
        # Create file item widget
        item = QListWidgetItem()
        
        file_widget = QWidget()
        layout = QVBoxLayout(file_widget)
        
        # File name
        name_label = QLabel(file_info['filename'])
        name_label.setStyleSheet("""
            font-weight: bold;
            color: white;
            font-size: 14px;
        """)
        
        # File details
        size_mb = file_info['size'] / 1024 / 1024
        details = (
            f"Size: {size_mb:.2f} MB | "
            f"Uploaded by: {file_info['uploader_name']}"
        )
        details_label = QLabel(details)
        details_label.setStyleSheet("color: #999; font-size: 11px;")
        
        # Download button
        download_btn = QPushButton("Download")
        download_btn.setStyleSheet("""
            QPushButton {
                background: #28a745;
                color: white;
                padding: 8px;
                border-radius: 5px;
                font-weight: bold;
            }
            QPushButton:hover {
                background: #218838;
            }
        """)
        download_btn.clicked.connect(
            lambda checked, fid=file_id, fn=file_info['filename'], 
                   fs=file_info['size']: 
                self.download_file(fid, fn, fs)
        )
        
        layout.addWidget(name_label)
        layout.addWidget(details_label)
        layout.addWidget(download_btn)
        
        item.setSizeHint(file_widget.sizeHint())
        self.file_list_widget.addItem(item)
        self.file_list_widget.setItemWidget(item, file_widget)
\end{lstlisting}

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.9\textwidth}{\centering
        \vspace{2cm}
        \textbf{[SCREENSHOT PLACEHOLDER]}\\
        \vspace{0.5cm}
        File Sharing Panel\\
        Showing list of shared files with upload/download buttons\\
        \vspace{2cm}
    }}
    \caption{File Sharing Interface}
    \label{fig:file-sharing}
\end{figure}

\section{File Management Features}

\begin{table}[H]
\centering
\caption{File Sharing Capabilities}
\label{tab:file-capabilities}
\begin{tabular}{ll}
\toprule
\textbf{Feature} & \textbf{Description} \\
\midrule
File Upload & Upload any file type up to 100 MB \\
File Download & Download files shared by other users \\
Progress Tracking & Real-time progress bars for uploads/downloads \\
File Metadata & Display filename, size, uploader, timestamp \\
Multiple Files & Support multiple files simultaneously \\
File Validation & Size limits and error handling \\
Session Persistence & Files available during entire session \\
Chunked Transfer & 8 KB chunks with acknowledgments \\
Cancellation & Ability to cancel ongoing transfers \\
File List & Real-time list of all shared files \\
\bottomrule
\end{tabular}
\end{table}

\section{Performance Considerations}

\subsection{Transfer Speed}

\begin{table}[H]
\centering
\caption{File Transfer Performance (LAN)}
\label{tab:transfer-speed}
\begin{tabular}{lrr}
\toprule
\textbf{File Size} & \textbf{Transfer Time} & \textbf{Speed} \\
\midrule
1 MB & 0.1 s & ~10 MB/s \\
10 MB & 1 s & ~10 MB/s \\
50 MB & 5 s & ~10 MB/s \\
100 MB & 10 s & ~10 MB/s \\
\bottomrule
\end{tabular}
\end{table}

Actual speeds depend on network conditions and server load.

\subsection{Memory Management}

Files are stored in server memory (\texttt{bytes} objects):
\begin{itemize}[itemsep=5pt]
    \item \textbf{Advantage}: Fast access, no disk I/O
    \item \textbf{Limitation}: Memory usage grows with file count
    \item \textbf{Maximum}: 100 MB per file, recommend $<$10 files
\end{itemize}

For production deployment, consider:
\begin{itemize}[itemsep=5pt]
    \item Disk-based storage for scalability
    \item File cleanup policies
    \item Database for metadata
    \item CDN for large files
\end{itemize}

% End of Chapter 8

% ============================================================================
% CHAPTER 9: USER INTERFACE DESIGN
% ============================================================================
\chapter{User Interface Design}

\section{Design Principles}

The user interface was designed following these principles:

\begin{itemize}[itemsep=5pt]
    \item \textbf{Simplicity}: Clean, uncluttered layout
    \item \textbf{Intuitiveness}: Common controls easily accessible
    \item \textbf{Responsiveness}: Real-time updates without lag
    \item \textbf{Material Design}: Modern, professional appearance
    \item \textbf{Dark Theme}: Reduced eye strain for extended use
\end{itemize}

\section{Main Window Layout}

The main application window consists of several key areas:

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.9\textwidth}{\centering
        \vspace{3cm}
        \textbf{[SCREENSHOT PLACEHOLDER]}\\
        \vspace{0.5cm}
        Main Application Window\\
        Showing all UI components: video grid, control bar, side panels\\
        \vspace{3cm}
    }}
    \caption{Main Application Window}
    \label{fig:main-window}
\end{figure}

\subsection{Window Structure}

\begin{lstlisting}[language=Python, caption=Main Window Layout, label=lst:main-layout]
def setup_main_window(self):
    """Create main window layout"""
    self.setWindowTitle("Video Conference Client")
    self.setGeometry(100, 100, 1400, 900)
    
    # Main container
    main_widget = QWidget()
    self.setCentralWidget(main_widget)
    main_layout = QHBoxLayout(main_widget)
    
    # Left panel (video grid + controls)
    left_panel = QVBoxLayout()
    
    # Video grid area
    video_scroll = QScrollArea()
    video_scroll.setWidgetResizable(True)
    video_container = QWidget()
    self.video_grid = QGridLayout(video_container)
    video_scroll.setWidget(video_container)
    
    # Control bar at bottom
    control_bar = self.create_control_bar()
    
    left_panel.addWidget(video_scroll, stretch=1)
    left_panel.addWidget(control_bar)
    
    # Right side tabs
    right_panel = self.create_side_panel()
    
    # Add to main layout
    main_layout.addLayout(left_panel, stretch=3)
    main_layout.addWidget(right_panel, stretch=1)
    
    # Apply dark theme stylesheet
    self.apply_dark_theme()
\end{lstlisting}

\section{Control Bar}

The bottom control bar provides quick access to all features:

\begin{lstlisting}[language=Python, caption=Control Bar Creation, label=lst:control-bar]
def create_control_bar(self):
    """Create bottom control bar with all controls"""
    control_widget = QWidget()
    control_widget.setFixedHeight(80)
    control_widget.setStyleSheet("""
        QWidget {
            background: #1e1e1e;
            border-top: 2px solid #333;
        }
    """)
    
    layout = QHBoxLayout(control_widget)
    layout.setContentsMargins(20, 10, 20, 10)
    
    # Video toggle button
    self.video_btn = self.create_control_button(
        "VID", "Start Video", "#28a745", 
        self.toggle_video
    )
    
    # Audio toggle button
    self.audio_btn = self.create_control_button(
        "MIC", "Unmute", "#28a745",
        self.toggle_audio
    )
    
    # Screen share button
    self.screen_btn = self.create_control_button(
        "SCR", "Share Screen", "#007bff",
        self.toggle_screen_share
    )
    
    # Settings button
    settings_btn = self.create_control_button(
        "SET", "Settings", "#6c757d",
        self.open_settings
    )
    
    # Disconnect button
    disconnect_btn = self.create_control_button(
        "END", "Leave", "#dc3545",
        self.disconnect
    )
    
    # Add buttons to layout
    layout.addWidget(self.video_btn)
    layout.addWidget(self.audio_btn)
    layout.addWidget(self.screen_btn)
    layout.addStretch()
    layout.addWidget(settings_btn)
    layout.addWidget(disconnect_btn)
    
    return control_widget

def create_control_button(self, icon, text, color, callback):
    """Create styled control button"""
    btn = QPushButton(f"{icon} {text}")
    btn.setFixedSize(150, 50)
    btn.setStyleSheet(f"""
        QPushButton {{
            background: {color};
            color: white;
            border-radius: 25px;
            font-size: 14px;
            font-weight: bold;
            border: none;
        }}
        QPushButton:hover {{
            background: {self.darken_color(color)};
        }}
        QPushButton:pressed {{
            background: {self.darken_color(color, 0.3)};
        }}
    """)
    btn.clicked.connect(callback)
    return btn
\end{lstlisting}

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.9\textwidth}{\centering
        \vspace{1.5cm}
        \textbf{[SCREENSHOT PLACEHOLDER]}\\
        \vspace{0.5cm}
        Control Bar\\
        Video, Audio, Screen Share, Settings, Leave buttons\\
        \vspace{1.5cm}
    }}
    \caption{Control Bar Interface}
    \label{fig:control-bar}
\end{figure}

\section{Side Panel Tabs}

The right side panel contains three tabs:

\subsection{Tab Structure}

\begin{lstlisting}[language=Python, caption=Side Panel Tabs, label=lst:side-tabs]
def create_side_panel(self):
    """Create tabbed side panel"""
    tab_widget = QTabWidget()
    tab_widget.setMinimumWidth(350)
    tab_widget.setStyleSheet("""
        QTabWidget::pane {
            border: 1px solid #333;
            background: #2a2a2a;
        }
        QTabBar::tab {
            background: #1e1e1e;
            color: white;
            padding: 10px 20px;
            margin: 2px;
        }
        QTabBar::tab:selected {
            background: #007bff;
        }
    """)
    
    # Chat tab
    chat_tab = self.create_chat_tab()
    tab_widget.addTab(chat_tab, "Chat")
    
    # People tab
    people_tab = self.create_people_tab()
    tab_widget.addTab(people_tab, "People")
    
    # Files tab
    files_tab = self.create_files_tab()
    tab_widget.addTab(files_tab, "Files")
    
    return tab_widget
\end{lstlisting}

\subsection{Chat Tab}

\begin{lstlisting}[language=Python, caption=Chat Tab Interface, label=lst:chat-tab]
def create_chat_tab(self):
    """Create chat interface tab"""
    chat_widget = QWidget()
    layout = QVBoxLayout(chat_widget)
    
    # Chat messages area
    chat_scroll = QScrollArea()
    chat_scroll.setWidgetResizable(True)
    
    chat_container = QWidget()
    self.chat_layout = QVBoxLayout(chat_container)
    self.chat_layout.addStretch()
    
    chat_scroll.setWidget(chat_container)
    
    # Input area
    input_layout = QHBoxLayout()
    
    self.chat_input = QLineEdit()
    self.chat_input.setPlaceholderText("Type a message...")
    self.chat_input.returnPressed.connect(self.send_chat_message)
    
    send_btn = QPushButton("Send")
    send_btn.clicked.connect(self.send_chat_message)
    
    input_layout.addWidget(self.chat_input)
    input_layout.addWidget(send_btn)
    
    layout.addWidget(chat_scroll)
    layout.addLayout(input_layout)
    
    return chat_widget
\end{lstlisting}

\subsection{People Tab}

\begin{lstlisting}[language=Python, caption=People Tab Interface, label=lst:people-tab]
def create_people_tab(self):
    """Create participants list tab"""
    people_widget = QWidget()
    layout = QVBoxLayout(people_widget)
    
    # Header with count
    self.people_count_label = QLabel("Participants (0)")
    self.people_count_label.setStyleSheet("""
        font-size: 16px;
        font-weight: bold;
        color: white;
        padding: 10px;
    """)
    
    # User list
    self.user_list_widget = QListWidget()
    self.user_list_widget.setStyleSheet("""
        QListWidget {
            background: #2a2a2a;
            border: none;
            color: white;
        }
        QListWidget::item {
            padding: 10px;
            border-bottom: 1px solid #333;
        }
        QListWidget::item:hover {
            background: #333;
        }
    """)
    
    layout.addWidget(self.people_count_label)
    layout.addWidget(self.user_list_widget)
    
    return people_widget
\end{lstlisting}

\subsection{Files Tab}

\begin{lstlisting}[language=Python, caption=Files Tab Interface, label=lst:files-tab]
def create_files_tab(self):
    """Create file sharing tab"""
    files_widget = QWidget()
    layout = QVBoxLayout(files_widget)
    
    # Upload button
    upload_btn = QPushButton("Upload File")
    upload_btn.setFixedHeight(40)
    upload_btn.setStyleSheet("""
        QPushButton {
            background: #007bff;
            color: white;
            font-weight: bold;
            border-radius: 5px;
        }
        QPushButton:hover {
            background: #0056b3;
        }
    """)
    upload_btn.clicked.connect(self.select_and_upload_file)
    
    # Files list
    self.file_list_widget = QListWidget()
    self.file_list_widget.setStyleSheet("""
        QListWidget {
            background: #2a2a2a;
            border: none;
        }
        QListWidget::item {
            padding: 5px;
        }
    """)
    
    layout.addWidget(upload_btn)
    layout.addWidget(QLabel("Shared Files:"))
    layout.addWidget(self.file_list_widget)
    
    return files_widget
\end{lstlisting}

\section{Video Grid Layout}

\subsection{Dynamic Grid Sizing}

The video grid dynamically adjusts based on participant count:

\begin{lstlisting}[language=Python, caption=Dynamic Video Grid, label=lst:dynamic-grid]
def update_video_grid_layout(self, user_count):
    """Adjust grid layout based on user count"""
    # Determine grid dimensions
    if user_count <= 1:
        rows, cols = 1, 1
    elif user_count <= 4:
        rows, cols = 2, 2
    elif user_count <= 6:
        rows, cols = 2, 3
    elif user_count <= 9:
        rows, cols = 3, 3
    else:
        rows, cols = 3, 4  # Max 12 users
    
    # Calculate cell size
    cell_width = self.width() // cols
    cell_height = self.height() // rows
    
    # Update each video label size
    for label in self.video_labels.values():
        label.setFixedSize(cell_width - 10, cell_height - 10)
\end{lstlisting}

\begin{table}[H]
\centering
\caption{Video Grid Configurations}
\label{tab:grid-layouts}
\begin{tabular}{lll}
\toprule
\textbf{User Count} & \textbf{Grid Layout} & \textbf{Positions} \\
\midrule
1 & 1 × 1 & Full screen \\
2-4 & 2 × 2 & 4 positions \\
5-6 & 2 × 3 & 6 positions \\
7-9 & 3 × 3 & 9 positions \\
10-12 & 3 × 4 & 12 positions \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Layout Modes}

The application supports different viewing layouts:

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.9\textwidth}{\centering
        \vspace{2cm}
        \textbf{[SCREENSHOT PLACEHOLDER]}\\
        \vspace{0.5cm}
        Tiled Layout View\\
        All participants in equal-sized grid\\
        \vspace{2cm}
    }}
    \caption{Tiled Layout - Equal Grid View}
    \label{fig:tiled-layout}
\end{figure}

\textbf{Tiled Layout:}
\begin{itemize}[itemsep=5pt]
    \item All participants shown in equal-sized tiles
    \item Automatically adjusts grid based on participant count
    \item Best for small to medium groups (2-9 users)
    \item Default layout mode
\end{itemize}

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.9\textwidth}{\centering
        \vspace{2cm}
        \textbf{[SCREENSHOT PLACEHOLDER]}\\
        \vspace{0.5cm}
        Spotlight Layout View\\
        Active speaker in large view, others in sidebar\\
        \vspace{2cm}
    }}
    \caption{Spotlight Layout - Active Speaker Focus}
    \label{fig:spotlight-layout}
\end{figure}

\textbf{Spotlight Layout:}
\begin{itemize}[itemsep=5pt]
    \item Active speaker shown in large main view
    \item Other participants in smaller sidebar tiles
    \item Automatically switches focus to current speaker
    \item Useful for presentations and lectures
    \item Can manually pin specific participant
\end{itemize}

\section{Connection Dialog}

\subsection{Initial Connection Screen}

\begin{lstlisting}[language=Python, caption=Connection Dialog, label=lst:connection-dialog]
def show_connection_dialog(self):
    """Show dialog to connect to server"""
    dialog = QDialog(self)
    dialog.setWindowTitle("Connect to Server")
    dialog.setFixedSize(400, 250)
    
    layout = QVBoxLayout(dialog)
    
    # Title
    title = QLabel("Video Conference")
    title.setStyleSheet("""
        font-size: 24px;
        font-weight: bold;
        color: #007bff;
        padding: 20px;
    """)
    title.setAlignment(Qt.AlignCenter)
    
    # Server IP input
    ip_layout = QHBoxLayout()
    ip_label = QLabel("Server IP:")
    ip_label.setFixedWidth(100)
    self.ip_input = QLineEdit("192.168.1.100")
    ip_layout.addWidget(ip_label)
    ip_layout.addWidget(self.ip_input)
    
    # Username input
    name_layout = QHBoxLayout()
    name_label = QLabel("Your Name:")
    name_label.setFixedWidth(100)
    self.name_input = QLineEdit()
    name_layout.addWidget(name_label)
    name_layout.addWidget(self.name_input)
    
    # Connect button
    connect_btn = QPushButton("Connect")
    connect_btn.setFixedHeight(40)
    connect_btn.setStyleSheet("""
        QPushButton {
            background: #28a745;
            color: white;
            font-size: 16px;
            font-weight: bold;
            border-radius: 5px;
        }
        QPushButton:hover {
            background: #218838;
        }
    """)
    connect_btn.clicked.connect(lambda: self.connect_to_server(
        self.ip_input.text(),
        self.name_input.text(),
        dialog
    ))
    
    layout.addWidget(title)
    layout.addLayout(ip_layout)
    layout.addLayout(name_layout)
    layout.addWidget(connect_btn)
    
    dialog.exec_()
\end{lstlisting}

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.7\textwidth}{\centering
        \vspace{2cm}
        \textbf{[SCREENSHOT PLACEHOLDER]}\\
        \vspace{0.5cm}
        Connection Dialog\\
        Input fields for server IP and username\\
        \vspace{2cm}
    }}
    \caption{Connection Dialog}
    \label{fig:connection-dialog}
\end{figure}

\section{Dark Theme Styling}

\subsection{Global Stylesheet}

\begin{lstlisting}[language=Python, caption=Dark Theme Implementation, label=lst:dark-theme]
def apply_dark_theme(self):
    """Apply dark theme to application"""
    self.setStyleSheet("""
        QMainWindow {
            background: #1a1a1a;
        }
        QWidget {
            background: #2a2a2a;
            color: white;
            font-family: 'Segoe UI', Arial;
        }
        QLabel {
            color: white;
        }
        QLineEdit {
            background: #3a3a3a;
            border: 2px solid #444;
            border-radius: 5px;
            padding: 8px;
            color: white;
        }
        QLineEdit:focus {
            border: 2px solid #007bff;
        }
        QPushButton {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
        }
        QPushButton:hover {
            background: #0056b3;
        }
        QPushButton:pressed {
            background: #004085;
        }
        QScrollArea {
            border: none;
            background: #2a2a2a;
        }
        QScrollBar:vertical {
            background: #2a2a2a;
            width: 12px;
        }
        QScrollBar::handle:vertical {
            background: #555;
            border-radius: 6px;
        }
        QScrollBar::handle:vertical:hover {
            background: #666;
        }
    """)
\end{lstlisting}

\section{User Experience Features}

\begin{table}[H]
\centering
\caption{UI/UX Features}
\label{tab:ux-features}
\begin{tabular}{ll}
\toprule
\textbf{Feature} & \textbf{Description} \\
\midrule
Responsive Layout & Adapts to window resizing \\
Visual Feedback & Button hover/press states \\
Loading Indicators & Progress bars for file transfers \\
Notifications & Toast messages for events \\
Tooltips & Helpful hints on hover \\
Keyboard Shortcuts & Enter to send, Esc to close \\
Auto-scroll & Chat scrolls to latest messages \\
User Indicators & Online status, video/audio active \\
Error Messages & Clear error dialogs \\
Confirmation Dialogs & Prevent accidental actions \\
\bottomrule
\end{tabular}
\end{table}

% ============================================================================
% CHAPTER 10: PERFORMANCE ANALYSIS
% ============================================================================
\chapter{Performance Analysis}

\section{Design Specifications}

The system was designed with the following performance targets based on the configuration in \texttt{config.py}:

\subsection{Video Specifications}

\begin{table}[H]
\centering
\caption{Video Configuration}
\label{tab:video-config}
\begin{tabular}{ll}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Resolution & 640 × 480 pixels \\
Target Frame Rate & 30 FPS \\
Compression & JPEG, Quality 60 \\
Protocol & UDP \\
Estimated Frame Size & 15-25 KB \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Audio Specifications}

\begin{table}[H]
\centering
\caption{Audio Configuration}
\label{tab:audio-config}
\begin{tabular}{ll}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Sample Rate & 44,100 Hz \\
Bit Depth & 16 bits \\
Channels & 1 (Mono) \\
Chunk Size & 1024 samples \\
Chunk Duration & ~23 ms \\
Protocol & UDP \\
Jitter Buffer Size & 10 chunks \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Screen Sharing Specifications}

\begin{table}[H]
\centering
\caption{Screen Sharing Configuration}
\label{tab:screen-config}
\begin{tabular}{ll}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Resolution & 960 × 540 pixels \\
Frame Rate & 10 FPS \\
Compression & JPEG, Quality 50 \\
Protocol & UDP (data), TCP (control) \\
Max Packet Size & 65,000 bytes \\
\bottomrule
\end{tabular}
\end{table}

\subsection{File Transfer Specifications}

\begin{table}[H]
\centering
\caption{File Transfer Configuration}
\label{tab:file-config}
\begin{tabular}{ll}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Protocol & TCP \\
Chunk Size & 8,192 bytes (8 KB) \\
Maximum File Size & 100 MB \\
Storage & In-memory (server RAM) \\
\bottomrule
\end{tabular}
\end{table}

\section{Theoretical Bandwidth Calculations}

\subsection{Video Bandwidth}

Raw video (uncompressed):
\begin{equation}
\text{Bandwidth} = \text{Width} \times \text{Height} \times \text{Channels} \times \text{Bit Depth} \times \text{FPS}
\end{equation}

\begin{equation}
= 640 \times 480 \times 3 \times 8 \times 30 = 221,184,000 \text{ bps} = 221 \text{ Mbps}
\end{equation}

With JPEG compression (quality 60):
\begin{itemize}
    \item Typical compression ratio: 10:1 to 15:1
    \item Estimated compressed frame size: 15-25 KB
    \item Bandwidth: $(20 \text{ KB} \times 8 \times 30 \text{ FPS}) = 4.8 \text{ Mbps}$
\end{itemize}

\subsection{Audio Bandwidth}

\begin{equation}
\text{Bandwidth} = \text{Sample Rate} \times \text{Bit Depth} \times \text{Channels}
\end{equation}

\begin{equation}
= 44,100 \times 16 \times 1 = 705,600 \text{ bps} = 705.6 \text{ Kbps}
\end{equation}

\subsection{Total Per-User Bandwidth (Theoretical)}

For a single user with all features active:

\textbf{Upload (to server):}
\begin{itemize}
    \item Video: 4-6 Mbps
    \item Audio: 0.7 Mbps
    \item Total: ~5-7 Mbps
\end{itemize}

\textbf{Download (from server):}
\begin{itemize}
    \item Video streams (from N-1 other users): $(N-1) \times 5$ Mbps
    \item Mixed audio: 0.7 Mbps
    \item Total: $5(N-1) + 0.7$ Mbps
\end{itemize}

For 6 users all transmitting video:
\begin{itemize}
    \item Upload: 6 Mbps per user
    \item Download: 25.7 Mbps per user (5 video streams + 1 audio)
\end{itemize}

\section{Network Protocol Distribution}

\begin{table}[H]
\centering
\caption{Port and Protocol Usage}
\label{tab:port-usage}
\begin{tabular}{lll}
\toprule
\textbf{Port} & \textbf{Protocol} & \textbf{Purpose} \\
\midrule
5000 & TCP & Control messages, chat \\
5001 & UDP & Video streaming \\
5002 & UDP & Audio streaming \\
5003 & TCP & Screen share control \\
5004 & UDP & Screen share data \\
5005 & TCP & File transfer \\
\bottomrule
\end{tabular}
\end{table}

\section{Scalability Considerations}

\subsection{User Limit Factors}

The system is designed for a maximum of 10 users (\texttt{MAX\_USERS = 10} in config).

\textbf{Primary bottlenecks:}
\begin{enumerate}[itemsep=5pt]
    \item \textbf{Bandwidth}: For 10 users all transmitting video
        \begin{itemize}
            \item Server uplink: $10 \times 6$ Mbps = 60 Mbps
            \item Server downlink: $10 \times 9 \times 5$ Mbps = 450 Mbps
            \item Client downlink: $9 \times 5$ Mbps = 45 Mbps per client
        \end{itemize}
    
    \item \textbf{CPU}: Server-side audio mixing
        \begin{itemize}
            \item Mixing N audio streams requires processing all streams
            \item NumPy operations scale with number of active users
        \end{itemize}
    
    \item \textbf{Memory}: Frame buffers and file storage
        \begin{itemize}
            \item Each video frame: 15-25 KB
            \item Audio chunks: 2 KB
            \item Files: up to 100 MB per file (in-memory)
        \end{itemize}
\end{enumerate}

\section{Compression Efficiency}

\subsection{Video Compression Analysis}

JPEG quality setting of 60 provides:
\begin{itemize}
    \item Good visual quality for video conferencing
    \item Compression ratio of approximately 10:1 to 15:1
    \item Balance between quality and bandwidth
\end{itemize}

\subsection{Screen Sharing Compression}

JPEG quality setting of 50 for screen sharing:
\begin{itemize}
    \item Slightly lower quality than video
    \item Sufficient for viewing shared content
    \item Lower bandwidth than video (10 FPS vs 30 FPS)
    \item Estimated frame size: 30-50 KB
    \item Bandwidth: ~3-5 Mbps
\end{itemize}

\section{Latency Components}

\subsection{Theoretical End-to-End Latency}

For LAN deployment with minimal network latency:

\textbf{Video Path:}
\begin{itemize}
    \item Capture buffer: ~33 ms (at 30 FPS)
    \item JPEG encoding: 5-10 ms
    \item Network transmission (LAN): 1-5 ms
    \item Server processing: <1 ms
    \item Network return: 1-5 ms
    \item JPEG decoding: 5-10 ms
    \item Display update: 16 ms (GUI refresh)
    \item \textbf{Total: 60-80 ms}
\end{itemize}

\textbf{Audio Path:}
\begin{itemize}
    \item Capture buffer (1024 samples @ 44.1kHz): 23 ms
    \item Network transmission: 1-5 ms
    \item Server mixing: <5 ms
    \item Network return: 1-5 ms
    \item Jitter buffer (10 chunks): 230 ms
    \item Playback buffer: 23 ms
    \item \textbf{Total: 280-290 ms}
\end{itemize}

\textbf{Note:} The jitter buffer introduces significant latency but ensures smooth audio playback despite network variations.

\section{System Resource Requirements}

\subsection{Client Resource Estimates}

\begin{table}[H]
\centering
\caption{Client Resource Usage (Estimated)}
\label{tab:client-resources}
\begin{tabular}{lr}
\toprule
\textbf{Component} & \textbf{Estimate} \\
\midrule
Base Application & 50-80 MB RAM \\
Video Processing & 5-10\% CPU \\
Audio Processing & 2-5\% CPU \\
GUI (PyQt6) & 30-50 MB RAM \\
Video Frame Buffers & ~10 MB per stream \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Server Resource Estimates}

\begin{table}[H]
\centering
\caption{Server Resource Usage (Estimated)}
\label{tab:server-resources}
\begin{tabular}{lr}
\toprule
\textbf{Component} & \textbf{Estimate} \\
\midrule
Base Application & 30-50 MB RAM \\
Audio Mixing (per stream) & 2-3\% CPU \\
Frame Buffering & 5-10 MB per user \\
File Storage & Variable (up to 100 MB/file) \\
Chat History & 1-2 MB (1000 messages) \\
\bottomrule
\end{tabular}
\end{table}

\section{Known Limitations}

\begin{enumerate}[itemsep=10pt]
    \item \textbf{Maximum Users}: System designed for 10 concurrent users
    \item \textbf{LAN-Optimized}: Performance may degrade over WAN
    \item \textbf{JPEG Compression}: Less efficient than modern codecs (H.264/H.265)
    \item \textbf{No Adaptive Quality}: Fixed quality settings regardless of network conditions
    \item \textbf{File Persistence}: Files stored in RAM, lost when server stops
    \item \textbf{Single Server}: No load balancing or redundancy
    \item \textbf{Audio Latency}: Jitter buffer adds ~230ms delay for stability
\end{enumerate}

% End of Chapter 10

% ============================================================================
% CHAPTER 11: INSTALLATION AND SETUP GUIDE
% ============================================================================
\chapter{Installation and Setup Guide}

\section{System Requirements}

\subsection{Minimum Requirements}

\begin{table}[H]
\centering
\caption{Minimum System Requirements}
\label{tab:min-requirements}
\begin{tabular}{ll}
\toprule
\textbf{Component} & \textbf{Requirement} \\
\midrule
Operating System & Windows 10/11, Linux, macOS \\
Python Version & 3.8 or higher \\
Processor & Dual-core 2.0 GHz \\
RAM & 4 GB \\
Network & 100 Mbps Ethernet or Wi-Fi \\
Webcam & 720p or higher \\
Microphone & Any \\
Speakers/Headphones & Any \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Recommended Specifications}

\begin{table}[H]
\centering
\caption{Recommended System Specifications}
\label{tab:rec-requirements}
\begin{tabular}{ll}
\toprule
\textbf{Component} & \textbf{Specification} \\
\midrule
Operating System & Windows 11 \\
Python Version & 3.10 or 3.11 \\
Processor & Quad-core 2.5 GHz or higher \\
RAM & 8 GB or more \\
Network & Gigabit Ethernet \\
Webcam & 1080p \\
Microphone & Noise-canceling \\
Speakers/Headphones & Good quality \\
\bottomrule
\end{tabular}
\end{table}

\section{Installation Steps}

\subsection{Step 1: Install Python}

\begin{enumerate}[itemsep=10pt]
    \item Download Python from \url{https://www.python.org/downloads/}
    \item Run the installer
    \item \textbf{Important}: Check "Add Python to PATH"
    \item Click "Install Now"
    \item Verify installation:
\end{enumerate}

\begin{lstlisting}[language=bash, caption=Verify Python Installation]
python --version
# Should output: Python 3.10.x or higher
\end{lstlisting}

\subsection{Step 2: Clone or Download Project}

\textbf{Option A: Using Git}
\begin{lstlisting}[language=bash]
git clone https://github.com/yourusername/video-conference.git
cd video-conference
\end{lstlisting}

\textbf{Option B: Download ZIP}
\begin{enumerate}[itemsep=5pt]
    \item Download project ZIP file
    \item Extract to desired location
    \item Open terminal/command prompt in project folder
\end{enumerate}

\subsection{Step 3: Install Dependencies}

\begin{lstlisting}[language=bash, caption=Install Required Packages]
pip install -r requirements.txt
\end{lstlisting}

This will install:
\begin{itemize}[itemsep=5pt]
    \item opencv-python==4.8.1.78
    \item numpy==1.24.3
    \item pyaudio==0.2.14
    \item PyQt6==6.6.0
    \item Pillow==10.0.0
    \item mss==9.0.1
\end{itemize}

\subsection{Step 4: Install PyAudio (Windows)}

PyAudio may require additional steps on Windows:

\begin{lstlisting}[language=bash]
# If pip install fails, download wheel from:
# https://www.lfd.uci.edu/~gohlke/pythonlibs/#pyaudio

# Install the downloaded .whl file:
pip install PyAudio-0.2.14-cp310-cp310-win_amd64.whl
\end{lstlisting}

\subsection{Step 5: Verify Installation}

\begin{lstlisting}[language=bash, caption=Test Imports]
python -c "import cv2; import numpy; import pyaudio; import PyQt6; import mss; print('All dependencies installed successfully!')"
\end{lstlisting}

\section{Network Configuration}

\subsection{Firewall Configuration}

The following ports must be allowed through the firewall:

\begin{table}[H]
\centering
\caption{Required Firewall Rules}
\label{tab:firewall-rules}
\begin{tabular}{llll}
\toprule
\textbf{Port} & \textbf{Protocol} & \textbf{Direction} & \textbf{Purpose} \\
\midrule
5000 & TCP & Both & Control/Chat \\
5001 & UDP & Both & Video Streaming \\
5002 & UDP & Both & Audio Streaming \\
5003 & TCP & Both & Screen Control \\
5004 & UDP & Both & Screen Data \\
5005 & TCP & Both & File Transfer \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Windows Firewall:}
\begin{lstlisting}[language=bash]
# Run as Administrator
netsh advfirewall firewall add rule name="Video Conference TCP" dir=in action=allow protocol=TCP localport=5000,5003,5005
netsh advfirewall firewall add rule name="Video Conference UDP" dir=in action=allow protocol=UDP localport=5001,5002,5004
\end{lstlisting}

\textbf{Linux (UFW):}
\begin{lstlisting}[language=bash]
sudo ufw allow 5000:5005/tcp
sudo ufw allow 5001:5002,5004/udp
\end{lstlisting}

\subsection{Finding Server IP Address}

\textbf{Windows:}
\begin{lstlisting}[language=bash]
ipconfig
# Look for "IPv4 Address" under your network adapter
# Example: 192.168.1.100
\end{lstlisting}

\textbf{Linux/Mac:}
\begin{lstlisting}[language=bash]
ifconfig
# or
ip addr show
# Look for inet address
\end{lstlisting}

\section{Running the Application}

\subsection{Starting the Server}

\textbf{Method 1: Python Script}
\begin{lstlisting}[language=bash]
cd src/server
python server.py
\end{lstlisting}

\textbf{Method 2: Batch Script (Windows)}
\begin{lstlisting}[language=bash]
start_server.bat
\end{lstlisting}

\textbf{Method 3: Shell Script (Linux/Mac)}
\begin{lstlisting}[language=bash]
chmod +x start_server.sh
./start_server.sh
\end{lstlisting}

\textbf{Expected Output:}
\begin{lstlisting}[language=bash]
Server starting...
TCP Control Server listening on port 5000
UDP Video Server listening on port 5001
UDP Audio Server listening on port 5002
TCP Screen Control Server listening on port 5003
UDP Screen Data Server listening on port 5004
TCP File Transfer Server listening on port 5005
Server ready! Waiting for clients...
\end{lstlisting}

\subsection{Starting a Client}

\textbf{Method 1: Python Script}
\begin{lstlisting}[language=bash]
cd src/client
python client.py
\end{lstlisting}

\textbf{Method 2: Batch Script (Windows)}
\begin{lstlisting}[language=bash]
start_client.bat
\end{lstlisting}

\textbf{Method 3: Shell Script (Linux/Mac)}
\begin{lstlisting}[language=bash]
chmod +x start_client.sh
./start_client.sh
\end{lstlisting}

\subsection{Connecting to Server}

\begin{enumerate}[itemsep=10pt]
    \item Client GUI will open with connection dialog
    \item Enter server IP address (e.g., 192.168.1.100)
    \item Enter your name/username
    \item Click "Connect"
    \item Wait for successful connection
    \item Main conference interface will appear
\end{enumerate}

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.8\textwidth}{\centering
        \vspace{2cm}
        \textbf{[SCREENSHOT PLACEHOLDER]}\\
        \vspace{0.5cm}
        Connection Dialog Example\\
        Server IP and Username fields\\
        \vspace{2cm}
    }}
    \caption{Client Connection Screen}
    \label{fig:connection-screen}
\end{figure}

\section{Building Executables (Optional)}

For easier deployment, you can build standalone executables.

\subsection{Install PyInstaller}

\begin{lstlisting}[language=bash]
pip install pyinstaller
\end{lstlisting}

\subsection{Build Server Executable}

\textbf{Windows:}
\begin{lstlisting}[language=bash]
build_server.bat
\end{lstlisting}

\textbf{Linux/Mac:}
\begin{lstlisting}[language=bash]
chmod +x build_server.sh
./build_server.sh
\end{lstlisting}

\textbf{Manual Build:}
\begin{lstlisting}[language=bash]
pyinstaller --onefile --name VideoConferenceServer src/server/server.py
\end{lstlisting}

\subsection{Build Client Executable}

\textbf{Windows:}
\begin{lstlisting}[language=bash]
build_client.bat
\end{lstlisting}

\textbf{Linux/Mac:}
\begin{lstlisting}[language=bash]
chmod +x build_client.sh
./build_client.sh
\end{lstlisting}

\textbf{Manual Build:}
\begin{lstlisting}[language=bash]
pyinstaller --onefile --windowed --name VideoConferenceClient src/client/client.py
\end{lstlisting}

Executables will be in \texttt{dist/} folder.

\section{Troubleshooting}

\subsection{Common Issues}

\begin{table}[H]
\centering
\caption{Common Installation Issues}
\label{tab:troubleshooting}
\begin{tabular}{ll}
\toprule
\textbf{Issue} & \textbf{Solution} \\
\midrule
"Python not found" & Add Python to PATH environment variable \\
PyAudio install fails & Download pre-compiled wheel for your Python version \\
OpenCV import error & Try: \texttt{pip install opencv-python-headless} \\
Port already in use & Kill process using port or change port in config \\
Camera not detected & Check permissions, close other apps using camera \\
No audio input/output & Check audio device settings, reinstall PyAudio \\
Connection refused & Verify server is running, check firewall \\
High CPU usage & Reduce video quality or frame rate in config \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Checking Logs}

Enable verbose logging for debugging:

\begin{lstlisting}[language=bash]
# Server
python server.py --verbose

# Client
python client.py --debug
\end{lstlisting}

\subsection{Testing Network Connectivity}

\begin{lstlisting}[language=bash]
# Test if server ports are reachable
telnet 192.168.1.100 5000

# Or use PowerShell (Windows)
Test-NetConnection -ComputerName 192.168.1.100 -Port 5000
\end{lstlisting}

% ============================================================================
% CHAPTER 12: USER GUIDE
% ============================================================================
\chapter{User Guide}

\section{Getting Started}

\subsection{First Time Setup}

\begin{enumerate}[itemsep=10pt]
    \item Launch the application
    \item Enter server IP address provided by host
    \item Choose a unique username
    \item Click "Connect"
    \item Allow camera and microphone access if prompted
\end{enumerate}

\section{Using Video Features}

\subsection{Starting Your Video}

\begin{enumerate}[itemsep=5pt]
    \item Click the \textbf{"Start Video"} button in the control bar
    \item Your video feed will appear in the grid
    \item Other participants will see your video
    \item Button changes to "Stop Video" with red color
\end{enumerate}

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.9\textwidth}{\centering
        \vspace{2cm}
        \textbf{[SCREENSHOT PLACEHOLDER]}\\
        \vspace{0.5cm}
        Video Active State\\
        Showing multiple video feeds in grid\\
        \vspace{2cm}
    }}
    \caption{Active Video Conference}
    \label{fig:active-video}
\end{figure}

\subsection{Stopping Your Video}

\begin{enumerate}[itemsep=5pt]
    \item Click the \textbf{"Stop Video"} button
    \item Your video feed will stop transmitting
    \item Your video window will show placeholder
    \item Button returns to green "Start Video"
\end{enumerate}

\section{Using Audio Features}

\subsection{Unmuting Your Microphone}

\begin{enumerate}[itemsep=5pt]
    \item Click the \textbf{"Unmute"} button
    \item Your microphone will be activated
    \item You'll hear other participants' audio
    \item Button changes to "Mute" with red color
\end{enumerate}

\subsection{Muting Your Microphone}

\begin{enumerate}[itemsep=5pt]
    \item Click the \textbf{"Mute"} button
    \item Your audio transmission stops
    \item You can still hear others
    \item Button returns to green "Unmute"
\end{enumerate}

\textbf{Tip:} Keep yourself muted when not speaking to reduce background noise.

\section{Screen Sharing}

\subsection{Starting Screen Share}

\begin{enumerate}[itemsep=10pt]
    \item Click the \textbf{"Share Screen"} button
    \item Wait for presenter role assignment
    \item If granted, your screen starts broadcasting
    \item All participants will see your screen
    \item Button changes to "Stop Sharing" with red color
\end{enumerate}

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.9\textwidth}{\centering
        \vspace{2cm}
        \textbf{[SCREENSHOT PLACEHOLDER]}\\
        \vspace{0.5cm}
        Screen Sharing View\\
        Presenter's screen displayed to viewers\\
        \vspace{2cm}
    }}
    \caption{Screen Sharing in Progress}
    \label{fig:screen-sharing-active}
\end{figure}

\subsection{Stopping Screen Share}

\begin{enumerate}[itemsep=5pt]
    \item Click the \textbf{"Stop Sharing"} button
    \item Your screen share ends
    \item Viewers return to video grid
    \item Other users can now request presenter role
\end{enumerate}

\textbf{Note:} Only one person can share screen at a time. If someone is already presenting, you'll receive a notification.

\section{Using Chat}

\subsection{Sending Group Messages}

\begin{enumerate}[itemsep=10pt]
    \item Click the \textbf{"Chat"} tab in the right panel
    \item Type your message in the input field at the bottom
    \item Press Enter or click "Send"
    \item Message appears for all participants
\end{enumerate}

\subsection{Sending Private Messages}

\begin{enumerate}[itemsep=10pt]
    \item Click the \textbf{"People"} tab
    \item Find the person you want to message
    \item Click the \textbf{"PM"} button next to their name
    \item Type your private message in the dialog
    \item Click "Send"
    \item Only the recipient sees this message
\end{enumerate}

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.7\textwidth}{\centering
        \vspace{2cm}
        \textbf{[SCREENSHOT PLACEHOLDER]}\\
        \vspace{0.5cm}
        Chat Interface\\
        Group and private messages with timestamps\\
        \vspace{2cm}
    }}
    \caption{Chat Panel View}
    \label{fig:chat-view}
\end{figure}

\textbf{Visual Indicators:}
\begin{itemize}[itemsep=5pt]
    \item Private messages show a [LOCK] icon
    \item Your own messages appear in blue
    \item Others' messages appear in gray
    \item Timestamps show when messages were sent
\end{itemize}

\section{File Sharing}

\subsection{Uploading a File}

\begin{enumerate}[itemsep=10pt]
    \item Click the \textbf{"Files"} tab in the right panel
    \item Click the \textbf{"Upload File"} button
    \item Select file from your computer (max 100 MB)
    \item Wait for upload progress to complete
    \item File becomes available to all participants
    \item Notification shows "Upload Complete"
\end{enumerate}

\subsection{Downloading a File}

\begin{enumerate}[itemsep=10pt]
    \item Go to the \textbf{"Files"} tab
    \item Browse the list of shared files
    \item Click \textbf{"Download"} on desired file
    \item Choose where to save the file
    \item Wait for download progress to complete
    \item File is saved to your chosen location
\end{enumerate}

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.7\textwidth}{\centering
        \vspace{2cm}
        \textbf{[SCREENSHOT PLACEHOLDER]}\\
        \vspace{0.5cm}
        File Sharing Panel\\
        List of shared files with download buttons\\
        \vspace{2cm}
    }}
    \caption{File Sharing Panel}
    \label{fig:files-panel}
\end{figure}

\textbf{File Information Displayed:}
\begin{itemize}[itemsep=5pt]
    \item Filename
    \item File size (in MB)
    \item Who uploaded it
    \item When it was uploaded
\end{itemize}

\section{Managing Participants}

\subsection{Viewing Participants}

\begin{enumerate}[itemsep=5pt]
    \item Click the \textbf{"People"} tab
    \item See list of all connected users
    \item Green dot (O) indicates online status
    \item Number shows total participant count
\end{enumerate}

\subsection{Participant Information}

For each participant you can see:
\begin{itemize}[itemsep=5pt]
    \item Username
    \item Online status
    \item Video active/inactive status
    \item Audio active/inactive status
    \item Option to send private message
\end{itemize}

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.7\textwidth}{\centering
        \vspace{2cm}
        \textbf{[SCREENSHOT PLACEHOLDER]}\\
        \vspace{0.5cm}
        Participants Panel\\
        List of connected users with status indicators\\
        and private message options\\
        \vspace{2cm}
    }}
    \caption{Participants List Panel}
    \label{fig:participants-panel}
\end{figure}

\section{Application Settings}

\subsection{Accessing Settings}

\begin{enumerate}[itemsep=5pt]
    \item Click the \textbf{"Settings"} button in the control bar
    \item Settings panel opens
    \item View current configuration values
\end{enumerate}

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.8\textwidth}{\centering
        \vspace{3cm}
        \textbf{[SCREENSHOT PLACEHOLDER]}\\
        \vspace{0.5cm}
        Settings Panel\\
        Displaying video, audio, screen sharing, and file transfer\\
        configuration options\\
        \vspace{3cm}
    }}
    \caption{Application Settings Panel}
    \label{fig:settings-panel}
\end{figure}

\subsection{Current Configuration}

The application uses configuration values defined in \texttt{src/common/config.py}:

\textbf{Video Settings:}
\begin{itemize}[itemsep=5pt]
    \item Resolution: 640×480 pixels
    \item Quality: JPEG compression quality 60
    \item Frame rate: 30 FPS
\end{itemize}

\textbf{Audio Settings:}
\begin{itemize}[itemsep=5pt]
    \item Sample rate: 44.1 kHz, 16-bit, mono
    \item Chunk size: 1024 samples
    \item Jitter buffer: 10 chunks
\end{itemize}

\textbf{Screen Sharing Settings:}
\begin{itemize}[itemsep=5pt]
    \item Resolution: 960×540 pixels
    \item Quality: JPEG compression quality 50
    \item Frame rate: 10 FPS
\end{itemize}

\textbf{File Transfer Settings:}
\begin{itemize}[itemsep=5pt]
    \item Maximum file size: 100 MB
    \item Chunk size: 8 KB
\end{itemize}

\textbf{Note:} These settings are currently configured in the code and require modification of the config file to change.

\section{Leaving the Conference}

\subsection{Graceful Disconnect}

\begin{enumerate}[itemsep=10pt]
    \item Click the \textbf{"Leave"} button (red button in control bar)
    \item Confirmation dialog appears
    \item Click "Yes" to confirm
    \item All your media stops transmitting
    \item Connection closes
    \item Application returns to connection screen or exits
\end{enumerate}

\textbf{What happens when you leave:}
\begin{itemize}[itemsep=5pt]
    \item Your video feed disappears for others
    \item Your audio stops transmitting
    \item If you were presenting, screen share ends
    \item Other participants are notified you left
    \item Your sent messages remain in chat history
\end{itemize}

\section{Keyboard Shortcuts}

\begin{table}[H]
\centering
\caption{Keyboard Shortcuts}
\label{tab:shortcuts}
\begin{tabular}{ll}
\toprule
\textbf{Shortcut} & \textbf{Action} \\
\midrule
Ctrl + V & Toggle video on/off \\
Ctrl + M & Toggle audio mute/unmute \\
Ctrl + S & Toggle screen share \\
Ctrl + Enter & Send chat message \\
Ctrl + Tab & Switch between tabs \\
Ctrl + Q & Leave conference \\
Esc & Close dialogs \\
\bottomrule
\end{tabular}
\end{table}

\section{Best Practices}

\subsection{For Best Video Quality}

\begin{itemize}[itemsep=5pt]
    \item Ensure good lighting in your room
    \item Position camera at eye level
    \item Use a neutral background
    \item Keep camera lens clean
    \item Avoid backlighting (windows behind you)
\end{itemize}

\subsection{For Best Audio Quality}

\begin{itemize}[itemsep=5pt]
    \item Use headphones to prevent echo
    \item Mute when not speaking
    \item Minimize background noise
    \item Speak clearly and at moderate volume
    \item Consider using external microphone
\end{itemize}

\subsection{For Smooth Performance}

\begin{itemize}[itemsep=5pt]
    \item Use wired Ethernet instead of Wi-Fi when possible
    \item Close unnecessary applications
    \item Don't run other bandwidth-heavy tasks
    \item Keep your software updated
    \item Monitor your network speed
\end{itemize}

% ============================================================================
% CHAPTER 13: CONCLUSION AND FUTURE WORK
% ============================================================================
\chapter{Conclusion and Future Work}

\section{Project Summary}

This project successfully developed a comprehensive LAN-based multi-user communication application featuring real-time video conferencing, audio conferencing, screen sharing, text chat, and file sharing capabilities. The system was designed with simplicity, performance, and usability in mind, targeting small to medium-sized groups in local network environments.

\subsection{Key Achievements}

\begin{enumerate}[itemsep=10pt]
    \item \textbf{Complete Multi-Modal Communication System}
    \begin{itemize}
        \item Real-time video streaming (640×480 @ 30 FPS)
        \item High-quality audio conferencing with server-side mixing
        \item Efficient screen sharing with presenter model
        \item Reliable text chat (group and private messaging)
        \item Robust file sharing up to 100 MB
    \end{itemize}
    
    \item \textbf{Optimized Network Protocols}
    \begin{itemize}
        \item Strategic use of TCP for reliability (chat, files, control)
        \item UDP for low-latency real-time media (video, audio, screen)
        \item Efficient bandwidth usage through JPEG compression
        \item Graceful handling of packet loss
    \end{itemize}
    
    \item \textbf{User-Friendly Interface}
    \begin{itemize}
        \item Modern dark-themed GUI using PyQt6
        \item Intuitive controls and clear visual feedback
        \item Dynamic video grid layout
        \item Organized side panels for chat, people, and files
    \end{itemize}
    
    \item \textbf{Modular Architecture}
    \begin{itemize}
        \item Supports up to 10 concurrent users
        \item Client-server model with centralized coordination
        \item Multi-threaded design for concurrent operations
        \item Efficient resource utilization
    \end{itemize}
\end{enumerate}

\section{Technical Implementation}

\subsection{Core Technologies Used}

\begin{itemize}[itemsep=5pt]
    \item \textbf{Python 3.8+}: Core programming language
    \item \textbf{Socket Programming}: TCP and UDP network communication
    \item \textbf{PyQt6}: Modern GUI framework
    \item \textbf{OpenCV}: Video capture and JPEG compression
    \item \textbf{PyAudio}: Audio input/output
    \item \textbf{NumPy}: Audio mixing and array operations
    \item \textbf{MSS}: Efficient screen capture
    \item \textbf{Threading}: Concurrent execution of multiple modules
\end{itemize}

\subsection{Implementation Highlights}

\begin{enumerate}[itemsep=10pt]
    \item \textbf{Server-Side Audio Mixing}
    \\Implemented using NumPy averaging to mix multiple audio streams without clipping, reducing client bandwidth requirements compared to peer-to-peer architectures.
    
    \item \textbf{Jitter Buffer for Audio}
    \\10-chunk queue-based buffer smooths audio playback despite network variations, trading ~230ms latency for stable audio quality.
    
    \item \textbf{JPEG Video Compression}
    \\Quality 60 compression reduces bandwidth from 221 Mbps (raw) to ~5 Mbps while maintaining acceptable visual quality.
    
    \item \textbf{Presenter-Based Screen Sharing}
    \\Single presenter at a time model with request/grant protocol prevents conflicts and simplifies coordination.
    
    \item \textbf{In-Memory File Storage}
    \\Files stored in server RAM during session enables fast access without disk I/O overhead.
    
    \item \textbf{Multi-Threaded Architecture}
    \\Separate threads for video capture, audio capture, network I/O, and GUI updates ensure responsive operation.
\end{enumerate}

\section{Lessons Learned}

\subsection{Technical Insights}

\begin{enumerate}[itemsep=10pt]
    \item \textbf{Protocol Selection Matters}
    \\UDP's unreliability is acceptable for video/audio where human perception tolerates minor losses, but TCP's reliability is essential for chat and files where complete delivery is crucial.
    
    \item \textbf{Server-Side Processing Reduces Complexity}
    \\Centralizing audio mixing and video broadcasting at the server simplifies client logic and reduces per-client bandwidth compared to peer-to-peer mesh networks.
    
    \item \textbf{Threading Requires Careful Synchronization}
    \\Multiple concurrent threads necessitate proper locking mechanisms to prevent race conditions, particularly for shared data structures like client lists and frame buffers.
    
    \item \textbf{Jitter Buffering Improves Audio Quality}
    \\Trading 200+ ms of latency for smooth audio playback through jitter buffering significantly improves user experience despite network variability.
    
    \item \textbf{Compression is Essential}
    \\JPEG compression reduces raw video bandwidth from ~221 Mbps to 4-6 Mbps, making multi-user video conferencing feasible on standard networks.
\end{enumerate}

\subsection{Development Challenges}

\begin{enumerate}[itemsep=10pt]
    \item \textbf{PyAudio Cross-Platform Installation}
    \\Audio I/O proved challenging across different operating systems, especially on Windows where pre-compiled wheels were often required.
    
    \item \textbf{Real-Time Performance Tuning}
    \\Balancing quality, latency, and bandwidth required careful parameter selection for JPEG quality, frame rates, and buffer sizes.
    
    \item \textbf{Thread Synchronization}
    \\Ensuring video, audio, and screen sharing modules work harmoniously without conflicts required careful design of locks and thread-safe data structures.
    
    \item \textbf{GUI Thread Safety}
    \\Preventing GUI freezing while handling intensive media processing necessitated proper use of PyQt6 signals and slots for cross-thread communication.
    
    \item \textbf{UDP Packet Size Limitations}
    \\Screen sharing frames had to be sized to fit within UDP packet limits (65KB), requiring lower resolution and quality than video.
\end{enumerate}

\section{Current Limitations}

\begin{enumerate}[itemsep=10pt]
    \item \textbf{User Scalability}: Designed for maximum 10 concurrent users due to bandwidth constraints
    \item \textbf{LAN-Only Deployment}: Optimized for local networks; WAN performance not tested
    \item \textbf{File Persistence}: Files stored in memory only; lost when server stops
    \item \textbf{JPEG Compression}: Less efficient than modern video codecs (H.264/H.265)
    \item \textbf{No Adaptive Quality}: Fixed quality settings regardless of network conditions
    \item \textbf{Single Server}: No redundancy or load balancing
    \item \textbf{Platform Dependencies}: PyAudio installation varies by platform
    \item \textbf{Audio Latency}: Jitter buffer adds significant delay for stability
\end{enumerate}

\section{Potential Future Enhancements}

While not currently implemented, the following enhancements could improve the system:

\subsection{Performance Improvements}

\begin{itemize}[itemsep=5pt]
    \item \textbf{Modern Video Codecs}: H.264/H.265 for 50-70\% bandwidth reduction
    \item \textbf{Audio Codec}: Opus for 80-90\% audio bandwidth reduction
    \item \textbf{Adaptive Bitrate}: Dynamically adjust quality based on network conditions
    \item \textbf{Selective Forwarding Unit (SFU)}: Scale to 50+ users by selective stream forwarding
\end{itemize}

\subsection{Feature Additions}

\begin{itemize}[itemsep=5pt]
    \item \textbf{Session Recording}: Record conferences for later playback
    \item \textbf{Virtual Backgrounds}: Background blur/replacement for privacy
    \item \textbf{Persistent File Storage}: Database-backed file storage
    \item \textbf{User Authentication}: Secure login and access control
    \item \textbf{Breakout Rooms}: Split participants into smaller groups
    \item \textbf{Mobile Clients}: iOS and Android applications
    \item \textbf{Cloud Deployment}: Scalable cloud-based architecture
\end{itemize}

\section{Practical Applications}

The developed system can be used in:

\begin{itemize}[itemsep=5pt]
    \item \textbf{Educational Institutions}: Remote learning, virtual classrooms, online lectures
    \item \textbf{Corporate Environments}: Team meetings, presentations, training sessions
    \item \textbf{Small Organizations}: Community meetings, virtual events
    \item \textbf{Development/Testing}: Testing platform for networked applications
\end{itemize}

\section{Contribution to Learning}

This project demonstrates practical application of:

\begin{itemize}[itemsep=5pt]
    \item \textbf{Network Protocols}: Real-world implementation of TCP/UDP socket programming
    \item \textbf{Multimedia Processing}: Video capture, compression, audio mixing
    \item \textbf{Concurrent Programming}: Multi-threaded application design
    \item \textbf{GUI Development}: Modern interface design with PyQt6
    \item \textbf{System Architecture}: Client-server model and state management
    \item \textbf{Performance Optimization}: Balancing quality, latency, and resources
\end{itemize}

\section{Final Remarks}

The LAN-based multi-user communication application successfully achieves its design goals, providing a feature-rich platform for real-time collaboration within local network environments. The modular architecture and well-documented codebase make it suitable for educational purposes and as a foundation for further development.

The implementation showcases fundamental concepts in network programming, multimedia processing, and distributed systems that are applicable to various domains of computer science and software engineering. While designed primarily for LAN deployment, the core concepts and techniques used in this project are directly relevant to commercial video conferencing solutions.

\vspace{1cm}
\begin{center}
\textit{This project demonstrates the integration of networking fundamentals,\\multimedia processing, and user interface design to create\\a functional real-time communication platform.}
\end{center}

% ============================================================================
% END OF DOCUMENT
% ============================================================================

\end{document}

